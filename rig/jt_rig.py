# LANCER. JT RIG TOOLS. Copyright 2018 Justin Tirado. All Rights Reserved.
#
#
#
#
#
import external.tf_smoothSkinWeight as tf_smoothSkinWeight
import skin
reload(skin)
# Maya Modules
import maya.cmds as cmds
import maya.mel as mel
import maya.api.OpenMaya as om

# Python Modules
import os
from math import *
import json

# Global Variables
pad = 5  # UI Padding
mar = 10  # UI Margins
col = 60  # UI Label Columns Width
isDebug = True  # Print Debugging Information


#########################################################################################################################
#																														#
#																														#
#	UTILITIES																											#
#																														#
#																														#
#########################################################################################################################

class componentType(object):
	left = 'left'
	right = 'right'
	center = 'center'

	fk = 'fk'
	ik = 'ik'
	bind = 'rig'
	fkik = 'fkik'
	character = 'character'
	set = 'set'
	noodle = 'noodle'

	root = 'root'
	cog = 'cog'
	hip = 'hip'
	spine = 'spine'
	neck = 'neck'
	head = 'head'
	arm = 'arm'
	collar = 'collar'
	leg = 'leg'
	hand = 'hand'
	foot = 'foot'
	finger = 'finger'
	toe = 'toe'
	limb = 'limb'
	digit = 'digit'

	thumb = 'thumb'
	index = 'index'
	middle = 'middle'
	ring = 'ring'
	pinky = 'pinky'


def listCheck(var, *args):
	if type(var) is str or type(var) is unicode:
		var = [str(var)]

	return var


def getSelected(*args):
	selected = cmds.ls(sl=True)

	if not selected:
		cmds.warning('Nothing selected.')

	return selected


def forwardAxis(obj, axis=[0, 0, 0], *args):
	x = axis[0] * 90
	y = axis[1] * 90
	z = axis[2] * 90
	var = [z, y, x]
	cmds.xform(obj, ro=var)
	freezeTransform(obj)
	return


def curveShape(n='curve', typ='circle', axis=[0, 0, 0], *args):
	# 2D
	if typ == 'circle':
		curve = cmds.circle(ch=False, nr=[0, 1, 0])[0]

	elif typ == 'square':
		curve = mel.eval('curve -d 1 -p 1 0 -1 -p -1 0 -1 -p -1 0 1 -p 1 0 1 -p 1 0 -1 -k 0 -k 1 -k 2 -k 3 -k 4 ')

	elif typ == 'lollipop':
		curve = cmds.curve(d=1, p=[[0.0, 0.0, 0.0], [0.0, 1.7123030076867394e-17, -0.07711527187363379],
		                           [0.0, 1.3698578170305682e-16, -0.6169291154329428],
		                           [0.0, 1.5410881177992419e-16, -0.6940443873065765],
		                           [-0.00851012261190444, 1.5461514005450124e-16, -0.6963246871352888],
		                           [-0.0680817468139299, 1.5815948354654102e-16, -0.7122869911653122],
		                           [-0.07659186942583439, 1.5866581182111808e-16, -0.7145672909940246],
		                           [-0.08282171190719884, 1.6004909286427333e-16, -0.7207970349845273],
		                           [-0.1264311699681803, 1.6973218466289893e-16, -0.7644058036006118],
		                           [-0.13266101244954473, 1.711154657060542e-16, -0.7706355475911146],
		                           [-0.1349412137873953, 1.7300507064991358e-16, -0.7791455717121571],
		                           [-0.15090282837252178, 1.8623247532307502e-16, -0.8387165064692857],
		                           [-0.15318302971037234, 1.8812208026693442e-16, -0.8472265305903284],
		                           [-0.15090282837252178, 1.9001172894952283e-16, -0.8557367516930947],
		                           [-0.1349412137873953, 2.0323943979772374e-16, -0.915309065340017],
		                           [-0.13266101244954473, 2.051290884803121e-16, -0.9238192864427831],
		                           [-0.1264311699681803, 2.0651236952346736e-16, -0.9300490304332858],
		                           [-0.08282171190719884, 2.1619546132209298e-16, -0.9736577990493704],
		                           [-0.07659186942583439, 2.1757874236524824e-16, -0.9798875430398731],
		                           [-0.0680817468139299, 2.180850706398253e-16, -0.9821678428685855],
		                           [-0.00851012261190444, 2.2162941413186505e-16, -0.9981301468986088],
		                           [0.0, 2.221357424064421e-16, -1.0004104467273212],
		                           [0.00851012261190444, 2.2162941413186505e-16, -0.9981301468986088],
		                           [0.06808174681392984, 2.180850706398253e-16, -0.9821678428685855],
		                           [0.07659186942583428, 2.1757874236524824e-16, -0.9798875430398731],
		                           [0.08282181039806058, 2.1619546132209298e-16, -0.9736577990493704],
		                           [0.12643195790393877, 2.0651236952346736e-16, -0.9300490304332858],
		                           [0.13266189887616509, 2.051290884803121e-16, -0.9238192864427831],
		                           [0.13494219870487742, 2.0323943979772374e-16, -0.915309065340017],
		                           [0.15090450273490078, 1.9001172894952283e-16, -0.8557367516930947],
		                           [0.1531848025636131, 1.8812208026693442e-16, -0.8472265305903284],
		                           [0.15090450273490078, 1.8623247532307502e-16, -0.8387165064692857],
		                           [0.13494219870487742, 1.7300507064991358e-16, -0.7791455717121571],
		                           [0.13266189887616509, 1.711154657060542e-16, -0.7706355475911146],
		                           [0.12643195790393877, 1.6973218466289893e-16, -0.7644058036006118],
		                           [0.08282181039806058, 1.6004909286427333e-16, -0.7207970349845273],
		                           [0.07659186942583428, 1.5866581182111808e-16, -0.7145672909940246],
		                           [0.06808174681392984, 1.5815948354654102e-16, -0.7122869911653122],
		                           [0.00851012261190444, 1.5461514005450124e-16, -0.6963246871352888],
		                           [0.0, 1.5410881177992419e-16, -0.6940443873065765]]
		                   )

	elif typ == 'triangle':
		curve = mel.eval(
			'curve -d 1 -p -1.03923 0 0.6 -p 1.03923 0 0.6 -p 0 0 -1.2 -p -1.03923 0 0.6 -k 0 -k 1 -k 2 -k 3')

	elif typ == 'house':
		curve = cmds.curve(d=1, p=[[0.0, 3.279783964168176e-16, 1.953102539721272],
		                           [-0.11110849598354955, 3.044371213540329e-16, 1.8470820621206885],
		                           [-0.8888779677330307, 1.39646077178597e-16, 1.1049291769782004],
		                           [-0.9999864637165801, 1.161048021158123e-16, 0.9989086993776168],
		                           [-0.9999864637165801, 6.676271792684901e-17, 0.7766917074105182],
		                           [-0.9999864637165801, -2.786363122278786e-16, -0.7788472360884438],
		                           [-0.9999864637165801, -3.2797839641684196e-16, -1.0010642280555428],
		                           [-0.7777694717494816, -3.2797839641684196e-16, -1.0010642280555428],
		                           [0.7777694717494814, -3.2797839641684196e-16, -1.0010642280555428],
		                           [0.9999864637165796, -3.2797839641684196e-16, -1.0010642280555428],
		                           [0.9999864637165796, -2.786363122278786e-16, -0.7788472360884438],
		                           [0.9999864637165796, 6.676271792684901e-17, 0.7766917074105182],
		                           [0.9999864637165796, 1.161048021158123e-16, 0.9989086993776168],
		                           [0.8888779677330305, 1.39646077178597e-16, 1.1049291769782004],
		                           [0.1111084959835491, 3.044371213540329e-16, 1.8470820621206885],
		                           [0.0, 3.279783964168176e-16, 1.953102539721272]])

	elif typ == 'hexagon':
		curve = cmds.curve(d=1, p=[[-0.574450699504812, -2.2092891843205653e-16, -0.9949753947259765],
		                           [-0.6382770987280193, -1.9638150630507065e-16, -0.8844236786179729],
		                           [-1.0850676377238437, -2.4547412126985984e-17, -0.11055171610800407],
		                           [-1.1488940369470508, -9.860761315262648e-32, -4.440892098500626e-16],
		                           [-1.0850676377238437, 2.4547412126985688e-17, 0.11055171610800274],
		                           [-0.6382770987280193, 1.963815063050705e-16, 0.8844236786179722],
		                           [-0.574450699504812, 2.209289184320563e-16, 0.9949753947259754],
		                           [-0.4467962650608528, 2.209289184320563e-16, 0.9949753947259754],
		                           [0.44679626506085235, 2.209289184320563e-16, 0.9949753947259754],
		                           [0.5744506995048115, 2.209289184320563e-16, 0.9949753947259754],
		                           [0.6382770987280186, 1.963815063050705e-16, 0.8844236786179722],
		                           [1.0850676377238435, 2.4547412126985688e-17, 0.11055171610800274],
		                           [1.1488940369470506, -9.860761315262648e-32, -4.440892098500626e-16],
		                           [1.0850676377238435, -2.4547412126985984e-17, -0.11055171610800407],
		                           [0.6382770987280186, -1.9638150630507065e-16, -0.8844236786179729],
		                           [0.5744506995048115, -2.2092891843205653e-16, -0.9949753947259765],
		                           [0.44679626506085235, -2.2092891843205653e-16, -0.9949753947259765],
		                           [-0.4467962650608528, -2.2092891843205653e-16, -0.9949753947259765],
		                           [-0.574450699504812, -2.2092891843205653e-16, -0.9949753947259765]])

	elif typ == 'octagon':
		curve = cmds.curve(d=1, p=[[0.4126197920965229, 2.2128754264414048e-16, 0.9965904945938838],
		                           [0.32102597570010905, 2.2128754264414048e-16, 0.9965904945938838],
		                           [-0.32013898260069795, 2.2128754264414048e-16, 0.9965904945938838],
		                           [-0.4117327989971117, 2.2128754264414048e-16, 0.9965904945938838],
		                           [-0.47665279252278614, 2.0689227484576619e-16, 0.9317599719012268],
		                           [-0.9310985900603521, 1.0612410467008825e-16, 0.47794047824723696],
		                           [-0.9960185835860264, 9.172883687171393e-17, 0.41310995555457986],
		                           [-0.9960185835860264, 9.172883687171393e-17, 0.41310995555457986],
		                           [-0.9960185835860264, 9.151908475957928e-17, 0.4121653160205301],
		                           [-0.9960185835860264, 9.151908475957928e-17, 0.4121653160205301],
		                           [-0.9960185835860264, 7.122087325478457e-17, 0.3207502982512491],
		                           [-0.9960185835860264, -7.068490074300092e-17, -0.31833649264689945],
		                           [-0.9960185835860264, -9.095689352874229e-17, -0.40963343180282163],
		                           [-0.9960185835860264, -9.102279763781024e-17, -0.40993023752386226],
		                           [-0.9960185835860264, -9.14841323327149e-17, -0.412007904283928],
		                           [-0.9960185835860264, -9.155003644178286e-17, -0.4123047100049686],
		                           [-0.931192566618773, -1.0596423380594239e-16, -0.4772204838830423],
		                           [-0.4774046134481289, -2.0686491264579542e-16, -0.9316367435076345],
		                           [-0.4125785964808756, -2.2127911000995506e-16, -0.9965525173857086],
		                           [-0.32098928580986563, -2.2128004695993938e-16, -0.9965567370333088],
		                           [0.32014413200759617, -2.2128660569415614e-16, -0.9965862749462835],
		                           [0.4117334426786061, -2.2128754264414046e-16, -0.9965904945938837],
		                           [0.47665336468482966, -2.0689225896525799e-16, -0.931759900381776],
		                           [0.9310986615798025, -1.0612397762459334e-16, -0.47793990608519343],
		                           [0.9960185835860265, -9.172869394571077e-17, -0.4131093118730853],
		                           [0.9960185835860265, -9.172869394571077e-17, -0.4131093118730853],
		                           [0.9960185835860265, -9.151906887907113e-17, -0.4121652445010795],
		                           [0.9960185835860265, -9.151906887907113e-17, -0.4121652445010795],
		                           [0.9960185835860265, -7.122087325478457e-17, -0.3207502982512491],
		                           [0.9960185835860265, 7.068490074300092e-17, 0.31833649264689945],
		                           [0.9960185835860265, 9.095689352874233e-17, 0.40963343180282186],
		                           [0.9960185835860265, 9.102281351831854e-17, 0.4099303090433135],
		                           [0.9960185835860265, 9.148425937820986e-17, 0.4120084764459717],
		                           [0.9960185835860265, 9.155017936778606e-17, 0.41230535368646337],
		                           [0.9311971438636277, 1.0596529780142181e-16, 0.4772252756926869],
		                           [0.4774412318189216, 2.0687242421050476e-16, 0.9316705725876604],
		                           [0.4126197920965229, 2.2128754264414048e-16, 0.9965904945938838]])

	elif typ == 'polySun':
		curve = cmds.curve(d=1, p=[[1.725228031871104, 1.6737089415854179e-15, -0.4622850343492457],
		                           [1.754883709555323, 1.685114149511624e-15, -0.41092054418270063],
		                           [1.9624761223825389, 1.7649516314740443e-15, -0.051364490166545096],
		                           [1.9921318000667587, 1.7763568394002505e-15, -8.881784197001252e-16],
		                           [1.9624761223825389, 1.7877620473264566e-15, 0.051364490166543764],
		                           [1.754883709555323, 1.8675995292888773e-15, 0.41092054418269974],
		                           [1.725228031871104, 1.879004737215083e-15, 0.4622850343492444],
		                           [1.725228031871104, 1.8921738456823898e-15, 0.521593426335409],
		                           [1.725228031871104, 1.984358790185151e-15, 0.936757508047215],
		                           [1.725228031871104, 1.997527898652458e-15, 0.9960659000333791],
		                           [1.6738644677615198, 2.0041125351364923e-15, 1.0257204664492456],
		                           [1.3143148962274345, 2.050205583147941e-15, 1.2333051002979762],
		                           [1.2629513321178503, 2.056790219631975e-15, 1.2629596667138427],
		                           [1.233297691758945, 2.0681950163062772e-15, 1.314322304766466],
		                           [1.0257195403922847, 2.148029619468357e-15, 1.6738653938184815],
		                           [0.9960659000333796, 2.1594344161426596e-15, 1.725228031871105],
		                           [0.9367565819902546, 2.1594344161426596e-15, 1.725228031871105],
		                           [0.5215860177963765, 2.1594344161426596e-15, 1.725228031871105],
		                           [0.46227669975325236, 2.1594344161426596e-15, 1.725228031871105],
		                           [0.41091313564366816, 2.166019299377836e-15, 1.754883709555324],
		                           [0.05136356410958287, 2.212114074669489e-15, 1.9624761223825395],
		                           [-8.881784197001252e-16, 2.2186989579046653e-15, 1.9921318000667587],
		                           [-0.05136541622350599, 2.212114074669489e-15, 1.9624761223825395],
		                           [-0.4109279527217331, 2.166019299377836e-15, 1.754883709555324],
		                           [-0.4622933689452382, 2.1594344161426596e-15, 1.725228031871105],
		                           [-0.521598982760521, 2.1594344161426596e-15, 1.725228031871105],
		                           [-0.936743617026115, 2.1594344161426596e-15, 1.725228031871105],
		                           [-0.9960492308413973, 2.1594344161426596e-15, 1.725228031871105],
		                           [-1.0257028712003033, 2.148030030720261e-15, 1.6738672459324029],
		                           [-1.2332810225669637, 2.0681983063585213e-15, 1.314337121844528],
		                           [-1.2629346629258698, 2.0567939209361232e-15, 1.262976335905826],
		                           [-1.3143000791493749, 2.050209078826137e-15, 1.233320843432999],
		                           [-1.6738626156476013, 2.0041145914145184e-15, 1.0257297271021981],
		                           [-1.7252280318711066, 1.9975297493045323e-15, 0.9960742346293712],
		                           [-1.7252280318711066, 1.9843602295853216e-15, 0.9367639905292857],
		                           [-1.7252280318711066, 1.8921724062822197e-15, 0.5215869438533391],
		                           [-1.7252280318711066, 1.879002886563009e-15, 0.4622766997532537],
		                           [-1.7548837095553256, 1.867597678636803e-15, 0.41091220958670904],
		                           [-1.9624761223825409, 1.7877601966743826e-15, 0.05135615557055262],
		                           [-1.9921318000667598, 1.7763549887481764e-15, -8.334595992032234e-06],
		                           [-1.9624761223825409, 1.7649497808219702e-15, -0.051372824762536684],
		                           [-1.7548837095553256, 1.68511229885955e-15, -0.4109288787786918],
		                           [-1.7252280318711066, 1.6737070909333438e-15, -0.46229336894523687],
		                           [-1.7252280318711066, 1.660538393717941e-15, -0.5215999088174805],
		                           [-1.7252280318711066, 1.56835632801552e-15, -0.9367510255651466],
		                           [-1.7252280318711066, 1.555187630800117e-15, -0.9960575654373898],
		                           [-1.6738663198754438, 1.5486029943160829e-15, -1.0257121318532558],
		                           [-1.314329713305499, 1.5025099463046342e-15, -1.2332967657019864],
		                           [-1.262968001309836, 1.4959253098206001e-15, -1.2629513321178525],
		                           [-1.2333125088370092, 1.484520307520346e-15, -1.3143148962274367],
		                           [-1.0257213925062079, 1.4046842649580961e-15, -1.6738644677615202],
		                           [-0.9960659000333814, 1.393279262657842e-15, -1.7252280318711044],
		                           [-0.9367565819902564, 1.393279262657842e-15, -1.7252280318711044],
		                           [-0.5215860177963796, 1.393279262657842e-15, -1.7252280318711044],
		                           [-0.4622766997532546, 1.393279262657842e-15, -1.7252280318711044],
		                           [-0.4109131356436708, 1.3866943794226655e-15, -1.7548837095553242],
		                           [-0.05136356410958509, 1.340599604131012e-15, -1.962476122382541],
		                           [-8.881784197001252e-16, 1.3340147208958355e-15, -1.99213180006676],
		                           [0.05136356410958287, 1.34059939850506e-15, -1.962477048439502],
		                           [0.41091313564366816, 1.3866927343965433e-15, -1.7548911180943554],
		                           [0.46227669975325236, 1.3932774120057677e-15, -1.7252363664670964],
		                           [0.5215860177963765, 1.3932774120057677e-15, -1.7252363664670964],
		                           [0.9367565819902546, 1.3932774120057677e-15, -1.7252363664670964],
		                           [0.9960659000333796, 1.3932774120057677e-15, -1.7252363664670964],
		                           [1.0257213925062065, 1.4046826199319737e-15, -1.6738718763005522],
		                           [1.2333125088370065, 1.4845201018943941e-15, -1.3143158222843967],
		                           [1.2629680013098334, 1.4959253098206001e-15, -1.2629513321178525],
		                           [1.3143297133054967, 1.5025097406786822e-15, -1.2332976917589473],
		                           [1.6738663198754407, 1.5486013492899608e-15, -1.025719540392286],
		                           [1.725228031871104, 1.5551857801480429e-15, -0.9960659000333809],
		                           [1.725228031871104, 1.5683548886153498e-15, -0.9367575080472159],
		                           [1.725228031871104, 1.6605398331181112e-15, -0.5215934263354103],
		                           [1.725228031871104, 1.6737089415854179e-15, -0.4622850343492457]])

	elif typ == 'locator':
		curve = cmds.curve(d=1, p=[[-1.0, 0.0, 0.0], [0.0, 0.0, 0.0], [0.0, 0.0, 1.0], [0.0, 0.0, 0.0], [1.0, 0.0, 0.0],
		                           [0.0, 0.0, 0.0], [0.0, 0.0, -1.0], [0.0, 0.0, 0.0], [0.0, 1.0, 0.0],
		                           [0.0, -1.0, 0.0]])

	elif typ == 'hexagon':
		curve = mel.eval(
			'curve  -d 1 -p -0.5 1 0.866025 -p 0.5 1 0.866025 -p 0.5 -1 0.866025 -p 1 -1 0 -p 1 1 0 -p 0.5 1 -0.866025 -p 0.5 -1 -0.866025 -p -0.5 -1 -0.866026 -p -0.5 1 -0.866026 -p -1 1 -1.5885e-007 -p -1 -1 -1.5885e-007 -p -0.5 -1 0.866025 -p -0.5 1 0.866025 -p -1 1 -1.5885e-007 -p -0.5 1 -0.866026 -p 0.5 1 -0.866025 -p 1 1 0 -p 0.5 1 0.866025 -p 0.5 -1 0.866025 -p -0.5 -1 0.866025 -p -1 -1 -1.5885e-007 -p -0.5 -1 -0.866026 -p 0.5 -1 -0.866025 -p 1 -1 0 -k 0 -k 1 -k 2 -k 3 -k 4 -k 5 -k 6 -k 7 -k 8 -k 9 -k 10 -k 11 -k 12 -k 13 -k 14 -k 15 -k 16 -k 17 -k 18 -k 19 -k 20 -k 21 -k 22 -k 23')

	elif typ == 'mover':
		curve = cmds.curve(d=1, p=[[3.0151795805144164, -1.8909139247979197e-21, -8.515919247109593e-06],
		                           [2.913475730972275, 2.2581152296350285e-17, 0.10169646906743957],
		                           [2.201539630739292, 1.806644872624896e-16, 0.8136405175144299],
		                           [2.0998357811971506, 2.0324753047276469e-16, 0.9153455025011166],
		                           [2.0998357811971506, 1.9473808270397915e-16, 0.8770223567004853],
		                           [2.0998357811971506, 1.3517118246452233e-16, 0.6087568869784521],
		                           [2.0998357811971506, 1.26661734695737e-16, 0.5704337411778218],
		                           [2.082763426259597, 1.26661734695737e-16, 0.5704337411778218],
		                           [1.9632554051694124, 1.26661734695737e-16, 0.5704337411778218],
		                           [1.9461830502318587, 1.26661734695737e-16, 0.5704337411778218],
		                           [1.9242937314005562, 1.4327190079283254e-16, 0.6452392790232633],
		                           [1.8983303968017107, 1.5949594226651045e-16, 0.7183058661585626],
		                           [1.868325406928459, 1.7525103708686965e-16, 0.7892605053207191],
		                           [1.8170306189388596, 2.021837022987446e-16, 0.9105544463330135],
		                           [1.7542580749887766, 2.277776004519526e-16, 1.0258191165187593],
		                           [1.6813737285253532, 2.517298071357609e-16, 1.1336902656146597],
		                           [1.6084910852457797, 2.7568201381956945e-16, 1.241561414710561],
		                           [1.525510264923661, 2.9799441994790296e-16, 1.342047558635863],
		                           [1.4337801891676487, 3.183622101961052e-16, 1.433775931208027],
		                           [1.3420518165954864, 3.3873037862709203e-16, 1.5255060069640387],
		                           [1.2415741885894307, 3.571573348230116e-16, 1.6084936400215546],
		                           [1.1336945235742824, 3.733390198247767e-16, 1.6813694705657305],
		                           [1.0258148585591358, 3.8952108300932683e-16, 1.7542470042937564],
		                           [0.9105501883733909, 4.034590095480773e-16, 1.8170178450599903],
		                           [0.7892647632803427, 4.148506313958656e-16, 1.8683211489688354],
		                           [0.7183101241181853, 4.2151496843197636e-16, 1.8983346547613351],
		                           [0.6452265051443926, 4.272799868055135e-16, 1.924297989360181],
		                           [0.570412451379704, 4.321422828714127e-16, 1.9461958241107298],
		                           [0.570412451379704, 4.3593310717866165e-16, 1.963268179048283],
		                           [0.570412451379704, 4.624692185070038e-16, 2.0827762001384666],
		                           [0.570412451379704, 4.662600428142527e-16, 2.09984855507602],
		                           [0.6087374895879099, 4.662600428142527e-16, 2.09984855507602],
		                           [0.8770162063332854, 4.662600428142527e-16, 2.09984855507602],
		                           [0.9153412445414912, 4.662600428142527e-16, 2.09984855507602],
		                           [0.8136372057585928, 4.888428339051924e-16, 2.2015524046181616],
		                           [0.1016997808232758, 6.469244040132927e-16, 2.9134885048511454],
		                           [-4.2579596231107075e-06, 6.695071951042323e-16, 3.0151923543932866],
		                           [-0.10170735053873425, 6.469244040132927e-16, 2.9134885048511454],
		                           [-0.813638151962381, 4.888428339051924e-16, 2.2015524046181616],
		                           [-0.9153412445414926, 4.662600428142527e-16, 2.09984855507602],
		                           [-0.8770180987408609, 4.662600428142527e-16, 2.09984855507602],
		                           [-0.6087526290188294, 4.662600428142527e-16, 2.09984855507602],
		                           [-0.5704294832181978, 4.662600428142527e-16, 2.09984855507602],
		                           [-0.5704294832181978, 4.624687983081115e-16, 2.082774307730892],
		                           [-0.5704294832181978, 4.359297455497046e-16, 1.9632530396173649],
		                           [-0.5704294832181978, 4.321385010435633e-16, 1.9461787922722364],
		                           [-0.6452350210636402, 4.27278095891589e-16, 1.9242894734409353],
		                           [-0.7183016081989386, 4.2151307751805176e-16, 1.898326138842089],
		                           [-0.789256247361096, 4.148506313958656e-16, 1.8683211489688354],
		                           [-0.91055018837339, 4.034590095480773e-16, 1.8170178450599903],
		                           [-1.025814858559135, 3.8952108300932683e-16, 1.7542470042937564],
		                           [-1.1336860076550361, 3.733390198247767e-16, 1.6813694705657305],
		                           [-1.241557156750937, 3.571573348230116e-16, 1.6084936400215546],
		                           [-1.342043300676239, 3.3873037862709203e-16, 1.5255060069640387],
		                           [-1.4337716732484025, 3.183622101961052e-16, 1.433775931208027],
		                           [-1.5255102649236614, 2.9799441994790296e-16, 1.342047558635863],
		                           [-1.608497897981177, 2.7568201381956945e-16, 1.241561414710561],
		                           [-1.6813737285253532, 2.517298071357609e-16, 1.1336902656146597],
		                           [-1.7542495590695297, 2.277776004519526e-16, 1.0258191165187593],
		                           [-1.8170221030196128, 2.021837022987446e-16, 0.9105544463330135],
		                           [-1.868325406928458, 1.7525103708686965e-16, 0.7892605053207191],
		                           [-1.898338912720958, 1.5949594226651045e-16, 0.7183058661585626],
		                           [-1.9243022473198041, 1.4327000987890774e-16, 0.6452307631040162],
		                           [-1.946191566151106, 1.266579528678876e-16, 0.5704167093393284],
		                           [-1.963262974884872, 1.266579528678876e-16, 0.5704167093393284],
		                           [-2.0827643724633846, 1.266579528678876e-16, 0.5704167093393284],
		                           [-2.09983578119715, 1.266579528678876e-16, 0.5704167093393284],
		                           [-2.09983578119715, 1.351678208355656e-16, 0.6087417475475352],
		                           [-2.09983578119715, 1.9473766250508669e-16, 0.8770204642929098],
		                           [-2.09983578119715, 2.0324753047276469e-16, 0.9153455025011166],
		                           [-2.2015396307392914, 1.8066490746138187e-16, 0.8136424099220045],
		                           [-2.913475730972275, 2.2584513925307415e-17, 0.10171160849835825],
		                           [-3.015179580514417, 1.8909139246007045e-21, 8.515919246221415e-06],
		                           [-2.913475730972275, -2.258094219690415e-17, -0.10169552286365224],
		                           [-2.2015396307392914, -1.8066280644801074e-16, -0.8136329477989692],
		                           [-2.09983578119715, -2.032456395588395e-16, -0.9153369865818677],
		                           [-2.09983578119715, -1.9473619179005396e-16, -0.8770138407812365],
		                           [-2.09983578119715, -1.3516929155059773e-16, -0.6087483710592059],
		                           [-2.09983578119715, -1.266598437818122e-16, -0.5704252252585746],
		                           [-2.082763426259597, -1.266598437818122e-16, -0.5704252252585746],
		                           [-1.9632554051694129, -1.266598437818122e-16, -0.5704252252585746],
		                           [-1.9461830502318593, -1.266598437818122e-16, -0.5704252252585746],
		                           [-1.9242937314005575, -1.4326811896498314e-16, -0.64522224718477],
		                           [-1.898338912720958, -1.5949594226651006e-16, -0.7183058661585608],
		                           [-1.868325406928458, -1.7524725525901985e-16, -0.789243473482224],
		                           [-1.8170221030196128, -2.0217802955697041e-16, -0.9105288985752731],
		                           [-1.7542495590695297, -2.27771927710178e-16, -1.0257935687610171],
		                           [-1.6813737285253532, -2.517260253079113e-16, -1.1336732337761655],
		                           [-1.608497897981177, -2.7568012290564446e-16, -1.241552898791313],
		                           [-1.5255102649236614, -2.9799063812005357e-16, -1.3420305267973696],
		                           [-1.4337716732484025, -3.183584283682556e-16, -1.4337588993695327],
		                           [-1.342043300676239, -3.3872659679924254e-16, -1.525488975125545],
		                           [-1.241557156750937, -3.57152040264022e-16, -1.6084697954476619],
		                           [-1.1336860076550361, -3.7333561617971217e-16, -1.6813541419110862],
		                           [-1.025814858559135, -3.8951919209540193e-16, -1.7542384883745088],
		                           [-0.91055018837339, -4.034571186341526e-16, -1.8170093291407436],
		                           [-0.789256247361096, -4.148468495680162e-16, -1.868304117130342],
		                           [-0.7183016081989386, -4.2150929569020216e-16, -1.8983091070035947],
		                           [-0.6452265051443931, -4.272743140637394e-16, -1.924272441602441],
		                           [-0.5704124513797044, -4.321385010435632e-16, -1.946178792272236],
		                           [-0.5704124513797044, -4.3592970352981514e-16, -1.9632528503766062],
		                           [-0.5704124513797044, -4.624684621452156e-16, -2.0827727937877993],
		                           [-0.5704124513797044, -4.662596646314677e-16, -2.0998468518921705],
		                           [-0.6087374895879107, -4.662596646314677e-16, -2.0998468518921705],
		                           [-0.8770162063332863, -4.662596646314677e-16, -2.0998468518921705],
		                           [-0.9153412445414926, -4.662596646314677e-16, -2.0998468518921705],
		                           [-0.8136400443699561, -4.888424977422965e-16, -2.201550890675069],
		                           [-0.1017224899696525, -6.469243619934035e-16, -2.9134883156103877],
		                           [-2.1289798115997627e-05, -6.695071951042322e-16, -3.015192354393286],
		                           [0.10168274898478291, -6.469243619934035e-16, -2.9134883156103877],
		                           [0.8136201739201003, -4.888424977422965e-16, -2.201550890675069],
		                           [0.9153242127029988, -4.662596646314677e-16, -2.0998468518921705],
		                           [0.8770010669023676, -4.662596646314677e-16, -2.0998468518921705],
		                           [0.6087355971803343, -4.662596646314677e-16, -2.0998468518921705],
		                           [0.570412451379704, -4.662596646314677e-16, -2.0998468518921705],
		                           [0.570412451379704, -4.624684621452156e-16, -2.0827727937877993],
		                           [0.570412451379704, -4.3592970352981514e-16, -1.9632528503766062],
		                           [0.570412451379704, -4.321385010435632e-16, -1.946178792272236],
		                           [0.6452265051443926, -4.272780958915888e-16, -1.9242894734409344],
		                           [0.7183101241181853, -4.2150929569020216e-16, -1.8983091070035947],
		                           [0.7892647632803427, -4.148468495680162e-16, -1.868304117130342],
		                           [0.9105501883733909, -4.034571186341526e-16, -1.8170093291407436],
		                           [1.0258148585591358, -3.8951919209540193e-16, -1.7542384883745088],
		                           [1.1336945235742824, -3.7333561617971217e-16, -1.6813541419110862],
		                           [1.2415741885894307, -3.57152040264022e-16, -1.6084697954476619],
		                           [1.3420518165954864, -3.3872659679924254e-16, -1.525488975125545],
		                           [1.4337801891676487, -3.183584283682556e-16, -1.4337588993695327],
		                           [1.525510264923661, -2.9799063812005357e-16, -1.3420305267973696],
		                           [1.6084910852457797, -2.7568012290564446e-16, -1.241552898791313],
		                           [1.6813737285253532, -2.517260253079113e-16, -1.1336732337761655],
		                           [1.7542580749887766, -2.27771927710178e-16, -1.0257935687610171],
		                           [1.8170306189388596, -2.0217802955697041e-16, -0.9105288985752731],
		                           [1.868325406928459, -1.7524725525901985e-16, -0.789243473482224],
		                           [1.8983303968017107, -1.5949594226651006e-16, -0.7183058661585608],
		                           [1.9242937314005562, -1.4326811896498314e-16, -0.64522224718477],
		                           [1.9461830502318587, -1.266598437818122e-16, -0.5704252252585746],
		                           [1.9632554051694124, -1.266598437818122e-16, -0.5704252252585746],
		                           [2.082763426259597, -1.266598437818122e-16, -0.5704252252585746],
		                           [2.0998357811971506, -1.266598437818122e-16, -0.5704252252585746],
		                           [2.0998357811971506, -1.351696697296008e-16, -0.6087500742260232],
		                           [2.0998357811971506, -1.947392172561154e-16, -0.8770274662690634],
		                           [2.0998357811971506, -2.03249043203904e-16, -0.915352315236512],
		                           [2.201539630739292, -1.8066625211296445e-16, -0.8136484656943708],
		                           [2.913475730972275, -2.2584682004864362e-17, -0.10171236546138829],
		                           [3.0151795805144164, -1.8909139247979197e-21, -8.515919247109593e-06]])

	elif typ == 'root':
		curve = cmds.curve(d=1, p=[[0.2218294764302727, 0.0, 0.6828598014335026],
		                           [0.32587850355211845, 0.0, 0.6397250275320987],
		                           [0.4219568140867114, 0.0, 0.58094421452366],
		                           [0.5075851250814857, 0.0, 0.5077780000314234],
		                           [0.580794895718574, 0.0, 0.4221909862856888],
		                           [0.6396163109311886, 0.0, 0.32614957104932624],
		                           [0.68278514203096, 0.0, 0.22213067701838332],
		                           [0.6907583491956443, 0.0, 0.18886638004070444],
		                           [1.0125939505313846, 0.0, -1.3773545452782852e-09],
		                           [0.6907583491956443, 0.0, -0.1888663800407037],
		                           [0.68278514203096, 0.0, -0.22213067701838285],
		                           [0.6396163109311886, 0.0, -0.3261495710493268],
		                           [0.580794895718574, 0.0, -0.4221909862856888],
		                           [0.5075851250814863, 0.0, -0.5077780000314229],
		                           [0.4219568140867114, 0.0, -0.58094421452366],
		                           [0.32587850355211845, 0.0, -0.6397250275320987],
		                           [0.2218294764302727, 0.0, -0.6828598014335029],
		                           [0.19368312783324698, 0.0, -0.6895990722818344],
		                           [1.634858076027285e-08, 0.0, -0.9971553823164439],
		                           [-0.19368312783324682, 0.0, -0.6895990722818344],
		                           [-0.22182949091037366, 0.0, -0.6828598593539077],
		                           [-0.32587850355211834, 0.0, -0.639725027532099],
		                           [-0.4219568140867111, 0.0, -0.58094421452366],
		                           [-0.5075851250814861, 0.0, -0.5077780000314229],
		                           [-0.5807948957185736, 0.0, -0.42219098628568885],
		                           [-0.6396163109311881, 0.0, -0.3261495710493265],
		                           [-0.6827851420309594, 0.0, -0.22213067701838332],
		                           [-0.6907583491956435, 0.0, -0.1888663800407037],
		                           [-1.0125939505313841, 0.0, -1.3773547610486093e-09],
		                           [-0.6907583491956435, 0.0, 0.1888663800407037],
		                           [-0.6827851420309594, 0.0, 0.22213067701838332],
		                           [-0.639616310931188, 0.0, 0.3261495710493268],
		                           [-0.5807948957185738, 0.0, 0.4221909862856888],
		                           [-0.5075851250814861, 0.0, 0.5077780000314234],
		                           [-0.4219568140867111, 0.0, 0.58094421452366],
		                           [-0.32587850355211845, 0.0, 0.6397250275320987],
		                           [-0.22182949091037366, 0.0, 0.6828598593539079],
		                           [-0.1936831278332464, 0.0, 0.6895990722818344],
		                           [1.634858076027285e-08, 0.0, 0.9971553823164439],
		                           [0.19368312783324698, 0.0, 0.6895990722818344],
		                           [0.2218294764302727, 0.0, 0.6828598014335026]])

	elif typ == 'center':
		curve = cmds.curve(d=1, p=[[0.7075841429448686, 0.0, -0.7065833927290376],
		                           [0.5882273123980648, 0.0, -0.8085696375059601],
		                           [0.45429696125840446, 0.0, -0.8905083279155774],
		                           [0.3092490747724388, 0.0, -0.9506396312682627],
		                           [0.1565403891316787, 0.0, -0.9872031687325976],
		                           [-5.017440972383839e-09, 0.0, -0.9995933782919307],
		                           [-0.1565404027852238, 0.0, -0.9872031687325975],
		                           [-0.3092490747724384, 0.0, -0.9506396312682625],
		                           [-0.4542969612584049, 0.0, -0.8905083279155777],
		                           [-0.5882273123980655, 0.0, -0.8085696375059602],
		                           [-0.707584142944869, 0.0, -0.7065833927290374],
		                           [-0.8096252749716774, 0.0, -0.5872906246141907],
		                           [-0.8916076567244877, 0.0, -0.45343299225385664],
		                           [-0.9517714555136723, 0.0, -0.3084628217445943],
		                           [-0.9883546540824442, 0.0, -0.15583594814396398],
		                           [-1.0007508712014663, 0.0, 0.0006195134860133334],
		                           [-0.9883542171690123, 0.0, 0.1570754442432544],
		                           [-0.9517708001435243, 0.0, 0.3097025909147799],
		                           [-0.8916069467401609, 0.0, 0.45467229720352037],
		                           [-0.8096246196015299, 0.0, 0.588529820335497],
		                           [-0.7075836514172581, 0.0, 0.707822588450344],
		                           [-0.5882267116420969, 0.0, 0.8098085601563718],
		                           [-0.4542965516520625, 0.0, 0.8917472505659894],
		                           [-0.30924915669370706, 0.0, 0.9518783900761366],
		                           [-0.17062897677573052, 0.0, 0.9850688466176288],
		                           [-5.017441277564346e-09, 0.0, 1.256016779206954],
		                           [0.1706289767757299, 0.0, 0.9850688466176288],
		                           [0.30924915669370634, 0.0, 0.9518783900761366],
		                           [0.4542965516520621, 0.0, 0.8917472505659894],
		                           [0.5882267116420965, 0.0, 0.8098085601563717],
		                           [0.7075836514172581, 0.0, 0.707822588450344],
		                           [0.8096246196015299, 0.0, 0.588529820335497],
		                           [0.8916069467401603, 0.0, 0.45467229720352126],
		                           [0.9517708001435239, 0.0, 0.30970259091478003],
		                           [0.9883542171690123, 0.0, 0.1570754442432539],
		                           [1.0007508712014663, 0.0, 0.00061951348601313],
		                           [0.9883546540824437, 0.0, -0.1558359481439638],
		                           [0.9517714555136718, 0.0, -0.30846282174459416],
		                           [0.8916076567244877, 0.0, -0.4534329922538561],
		                           [0.8096252749716769, 0.0, -0.5872906246141906],
		                           [0.7075841429448686, 0.0, -0.7065833927290376]])


	# 3D
	elif typ == 'pyramid':
		curve = mel.eval(
			'curve  -d 1 -p -1 0 0 -p 0 0 1 -p 0 1 0 -p -1 0 0 -p 1 0 0 -p 0 1 0 -p 1 0 0 -p 0 0 1 -p 0 1 0 -k 0 -k 1 -k 2 -k 3 -k 4 -k 5 -k 6 -k 7 -k 8')

	elif typ == 'cube':
		curve = mel.eval(
			'curve -d 1 -p 0.5 0.5 0.5 -p 0.5 0.5 -0.5 -p -0.5 0.5 -0.5 -p -0.5 -0.5 -0.5 -p 0.5 -0.5 -0.5 -p 0.5 0.5 -0.5 -p -0.5 0.5 -0.5 -p -0.5 0.5 0.5 -p 0.5 0.5 0.5 -p 0.5 -0.5 0.5 -p 0.5 -0.5 -0.5 -p -0.5 -0.5 -0.5 -p -0.5 -0.5 0.5 -p 0.5 -0.5 0.5 -p -0.5 -0.5 0.5 -p -0.5 0.5 0.5 -k 0 -k 1 -k 2 -k 3 -k 4 -k 5 -k 6 -k 7 -k 8 -k 9 -k 10 -k 11 -k 12 -k 13 -k 14 -k 15')

	elif typ == 'rombus':
		curve = mel.eval(
			'curve -d 1 -p 0 1 0 -p 1 0 0 -p 0 0 1 -p -1 0 0 -p 0 0 -1 -p 0 1 0 -p 0 0 1 -p 0 -1 0 -p 0 0 -1 -p 1 0 0 -p 0 1 0 -p -1 0 0 -p 0 -1 0 -p 1 0 0 -k 0 -k 1 -k 2 -k 3 -k 4 -k 5 -k 6 -k 7 -k 8 -k 9 -k 10 -k 11 -k 12 -k 13')

	elif typ == 'cone':
		curve = mel.eval(
			'curve -d 1 -p 0.5 -1 0.866025 -p -0.5 -1 0.866025 -p 0 1 0 -p 0.5 -1 0.866025 -p 1 -1 0 -p 0 1 0 -p 0.5 -1 -0.866025 -p 1 -1 0 -p 0 1 0 -p -0.5 -1 -0.866026 -p 0.5 -1 -0.866025 -p 0 1 0 -p -1 -1 -1.5885e-007 -p -0.5 -1 -0.866026 -p 0 1 0 -p -0.5 -1 0.866025 -p -1 -1 -1.5885e-007 -k 0 -k 1 -k 2 -k 3 -k 4 -k 5 -k 6 -k 7 -k 8 -k 9 -k 10 -k 11 -k 12 -k 13 -k 14 -k 15 -k 16')

	elif typ == 'rotateSphere':
		curve = mel.eval(
			'curve -d 1 -p 0 0.35 -1.001567 -p -0.336638 0.677886 -0.751175 -p -0.0959835 0.677886 -0.751175 -p -0.0959835 0.850458 -0.500783 -p -0.0959835 0.954001 -0.0987656 -p -0.500783 0.850458 -0.0987656 -p -0.751175 0.677886 -0.0987656 -p -0.751175 0.677886 -0.336638 -p -1.001567 0.35 0 -p -0.751175 0.677886 0.336638 -p -0.751175 0.677886 0.0987656 -p -0.500783 0.850458 0.0987656 -p -0.0959835 0.954001 0.0987656 -p -0.0959835 0.850458 0.500783 -p -0.0959835 0.677886 0.751175 -p -0.336638 0.677886 0.751175 -p 0 0.35 1.001567 -p 0.336638 0.677886 0.751175 -p 0.0959835 0.677886 0.751175 -p 0.0959835 0.850458 0.500783 -p 0.0959835 0.954001 0.0987656 -p 0.500783 0.850458 0.0987656 -p 0.751175 0.677886 0.0987656 -p 0.751175 0.677886 0.336638 -p 1.001567 0.35 0 -p 0.751175 0.677886 -0.336638 -p 0.751175 0.677886 -0.0987656 -p 0.500783 0.850458 -0.0987656 -p 0.0959835 0.954001 -0.0987656 -p 0.0959835 0.850458 -0.500783 -p 0.0959835 0.677886 -0.751175 -p 0.336638 0.677886 -0.751175 -p 0 0.35 -1.001567 -k 0 -k 1 -k 2 -k 3 -k 4 -k 5 -k 6 -k 7 -k 8 -k 9 -k 10 -k 11 -k 12 -k 13 -k 14 -k 15 -k 16 -k 17 -k 18 -k 19 -k 20 -k 21 -k 22 -k 23 -k 24 -k 25 -k 26 -k 27 -k 28 -k 29 -k 30 -k 31 -k 32')

	elif typ == 'jack':
		curve = mel.eval(
			'curve -d 1 -p 0 0 0 -p 0.75 0 0 -p 1 0.25 0 -p 1.25 0 0 -p 1 -0.25 0 -p 0.75 0 0 -p 1 0 0.25 -p 1.25 0 0 -p 1 0 -0.25 -p 1 0.25 0 -p 1 0 0.25 -p 1 -0.25 0 -p 1 0 -0.25 -p 0.75 0 0 -p 0 0 0 -p -0.75 0 0 -p -1 0.25 0 -p -1.25 0 0 -p -1 -0.25 0 -p -0.75 0 0 -p -1 0 0.25 -p -1.25 0 0 -p -1 0 -0.25 -p -1 0.25 0 -p -1 0 0.25 -p -1 -0.25 0 -p -1 0 -0.25 -p -0.75 0 0 -p 0 0 0 -p 0 0.75 0 -p 0 1 -0.25 -p 0 1.25 0 -p 0 1 0.25 -p 0 0.75 0 -p -0.25 1 0 -p 0 1.25 0 -p 0.25 1 0 -p 0 1 0.25 -p -0.25 1 0 -p 0 1 -0.25 -p 0.25 1 0 -p 0 0.75 0 -p 0 0 0 -p 0 -0.75 0 -p 0 -1 -0.25 -p 0 -1.25 0 -p 0 -1 0.25 -p 0 -0.75 0 -p -0.25 -1 0 -p 0 -1.25 0 -p 0.25 -1 0 -p 0 -1 -0.25 -p -0.25 -1 0 -p 0 -1 0.25 -p 0.25 -1 0 -p 0 -0.75 0 -p 0 0 0 -p 0 0 -0.75 -p 0 0.25 -1 -p 0 0 -1.25 -p 0 -0.25 -1 -p 0 0 -0.75 -p -0.25 0 -1 -p 0 0 -1.25 -p 0.25 0 -1 -p 0 0.25 -1 -p -0.25 0 -1 -p 0 -0.25 -1 -p 0.25 0 -1 -p 0 0 -0.75 -p 0 0 0 -p 0 0 0.75 -p 0 0.25 1 -p 0 0 1.25 -p 0 -0.25 1 -p 0 0 0.75 -p -0.25 0 1 -p 0 0 1.25 -p 0.25 0 1 -p 0 0.25 1 -p -0.25 0 1 -p 0 -0.25 1 -p 0.25 0 1 -p 0 0 0.75 -k 0 -k 1 -k 2 -k 3 -k 4 -k 5 -k 6 -k 7 -k 8 -k 9 -k 10 -k 11 -k 12 -k 13 -k 14 -k 15 -k 16 -k 17 -k 18 -k 19 -k 20 -k 21 -k 22 -k 23 -k 24 -k 25 -k 26 -k 27 -k 28 -k 29 -k 30 -k 31 -k 32 -k 33 -k 34 -k 35 -k 36 -k 37 -k 38 -k 39 -k 40 -k 41 -k 42 -k 43 -k 44 -k 45 -k 46 -k 47 -k 48 -k 49 -k 50 -k 51 -k 52 -k 53 -k 54 -k 55 -k 56 -k 57 -k 58 -k 59 -k 60 -k 61 -k 62 -k 63 -k 64 -k 65 -k 66 -k 67 -k 68 -k 69 -k 70 -k 71 -k 72 -k 73 -k 74 -k 75 -k 76 -k 77 -k 78 -k 79 -k 80 -k 81 -k 82 -k 83')

	elif typ == 'cylinder':
		curve = cmds.curve(d=1, p=[[0.679679916801789, -1.000000000044628, -0.6796799168017885],
		                           [0.40061606951095025, -0.999999999955372, -0.881130506956122],
		                           [0.0, -1.0000000000207325, -0.9919069536021649],
		                           [-0.40061606951095025, -0.999999999955372, -0.881130506956122],
		                           [-0.679679916801789, -1.0000000000404505, -0.6796799168017885],
		                           [-0.8963889927940835, -0.999999999955372, -0.38195394242101793],
		                           [-0.9919069536021655, -1.0000000000207325, 0.0],
		                           [-0.8963889927940835, -0.999999999955372, 0.38195394242101793],
		                           [-0.679679916801789, -1.0000000000391147, 0.6796799168017885],
		                           [-0.40061606951095025, -0.999999999955372, 0.881130506956122],
		                           [0.0, -1.0000000000207325, 0.9919069536021649],
		                           [0.40061606951095025, -0.999999999955372, 0.881130506956122],
		                           [0.679679916801789, -1.000000000044628, 0.6796799168017885],
		                           [0.679679916801789, 1.000000001328982, 0.6796799168017885],
		                           [0.8963889927940835, 0.9999999986710176, 0.38195394242101793],
		                           [0.9919069536021655, 1.0000000006173997, 0.0],
		                           [0.8963889927940835, 0.9999999986710176, -0.38195394242101793],
		                           [0.679679916801789, 1.000000001328982, -0.6796799168017885],
		                           [0.40061606951095025, 0.9999999986710176, -0.881130506956122],
		                           [0.0, 1.0000000006173997, -0.9919069536021649],
		                           [-0.40061606951095025, 0.9999999986710176, -0.881130506956122],
		                           [-0.679679916801789, 1.000000001328982, -0.6796799168017885],
		                           [-0.8963889927940835, 0.9999999986710176, -0.38195394242101793],
		                           [-0.9919069536021655, 1.0000000006173997, 0.0],
		                           [-0.8963889927940835, 0.9999999986710176, 0.38195394242101793],
		                           [-0.679679916801789, 1.000000001328982, 0.6796799168017885],
		                           [-0.679679916801789, -1.000000000044628, 0.6796799168017885],
		                           [-0.8963889927940835, -0.999999999955372, 0.38195394242101793],
		                           [-0.9919069536021655, -1.0000000000207325, 0.0],
		                           [-0.8963889927940835, -0.999999999955372, -0.38195394242101793],
		                           [-0.679679916801789, -1.000000000044628, -0.6796799168017885],
		                           [-0.679679916801789, 1.000000001328982, -0.6796799168017885],
		                           [-0.40061606951095025, 0.9999999986710176, -0.881130506956122],
		                           [0.0, 1.0000000006173997, -0.9919069536021649],
		                           [0.40061606951095025, 0.9999999986710176, -0.881130506956122],
		                           [0.679679916801789, 1.000000001328982, -0.6796799168017885],
		                           [0.679679916801789, -1.000000000044628, -0.6796799168017885],
		                           [0.8963889927940835, -0.999999999955372, -0.38195394242101793],
		                           [0.9919069536021655, -1.0000000000207325, 0.0],
		                           [0.8963889927940835, -0.999999999955372, 0.38195394242101793],
		                           [0.679679916801789, -1.000000000044628, 0.6796799168017885],
		                           [0.679679916801789, 1.000000001328982, 0.6796799168017885],
		                           [0.40061606951095025, 0.9999999986710176, 0.881130506956122],
		                           [0.0, 1.0000000006173997, 0.9919069536021649],
		                           [-0.40061606951095025, 0.9999999986710176, 0.881130506956122],
		                           [-0.679679916801789, 1.000000001328982, 0.6796799168017885]])

	curve = cmds.rename(curve, n)

	return curve


def scaleCurve(selected=[], *args):
	curveList = []

	if not selected:
		getSelected()

	if selected:
		for obj in selected:
			shape = cmds.listRelatives(obj, shapes=True)[0]

			if cmds.objectType(shape, isType='nurbsCurve'):
				curveList.append(obj)

		for obj in curveList:
			curveCVs = cmds.ls('{}.cv[:]'.format(obj), fl=True)
			cmds.scale(1.5, 1.5, 1.5, curveCVs, r=True)

		cmds.select(curveList)

	return


def control(child='', n='control', typ='circle', axis=[0, 0, 0], t=True, r=True, parent=True, scale=1, nest=False,
            *args):
	ctl = curveShape(n=n, typ=typ, axis=axis)
	grp = cmds.group(ctl, n='{}_grp'.format(ctl))
	forwardAxis(ctl, axis=axis)

	for axis in ['x', 'y', 'z']:
		cmds.setAttr('{}.s{}'.format(ctl, axis), scale)

	cmds.setAttr('{}.v'.format(ctl), k=False, channelBox=False)
	cmds.setAttr('{}.rotateOrder'.format(ctl), k=True)

	freezeTransform(ctl)

	ctlPos = cmds.xform(ctl, q=True, rp=True, ws=True)
	cmds.xform(grp, rp=ctlPos, ws=True)

	if child:
		snap(child, grp, t=t, r=r)

		if nest:
			cmds.parent(child, ctl)

		else:
			if parent:
				cmds.parentConstraint(ctl, child, mo=True)



	return [ctl, grp]


def snap(par, child, t=False, r=False):
	parPosition = cmds.xform(par, q=True, ws=True, rp=True)
	parRotation = cmds.xform(par, q=True, ws=True, ro=True)

	if t:
		cmds.xform(child, t=parPosition, ws=True)

	if r:
		cmds.xform(child, ro=parRotation, ws=True)

	return


def createGroup(obj, n='', *args):
	if not n:
		n = '{}_grp'.format(obj)

	if cmds.objExists(n):
		n = '{}#'.format(n)

	grp = cmds.group(n=n, em=True)
	snap(obj, grp, t=True, r=True)
	par = cmds.listRelatives(obj, parent=True)

	if par:
		cmds.parent(grp, par)

	cmds.parent(obj, grp)

	return grp


def createLocalWorld(obj, local, world, n='localWorld', t=False, r=True):
	name = '{}_{}'.format(obj, n)

	if cmds.objExists(name):
		name = '{}0'.format(name)

	null = createGroup(obj, n=name)

	cmds.addAttr(obj, ln=n, min=0, max=1, dv=0, k=True)

	if t and r:
		pc = cmds.parentConstraint(local, world, null, mo=True)[0]
		pcAttr = cmds.parentConstraint(pc, q=True, wal=True)

	elif t and not r:
		pc = cmds.parentConstraint(local, world, null, sr=['x', 'y', 'z'], mo=True)[0]
		pcAttr = cmds.parentConstraint(pc, q=True, wal=True)

	elif r and not t:
		pc = cmds.parentConstraint(local, world, null, st=['x', 'y', 'z'], mo=True)[0]
		pcAttr = cmds.parentConstraint(pc, q=True, wal=True)

	cmds.connectAttr('{}.{}'.format(obj, n), '{}.{}'.format(pc, pcAttr[-1]))

	reverse = cmds.createNode('reverse')
	cmds.connectAttr('{}.{}'.format(obj, n), '{}.inputX'.format(reverse))
	cmds.connectAttr('{}.outputX'.format(reverse), '{}.{}'.format(pc, pcAttr[0]))

	return [null, pc]


def getPositionSide(obj, *args):
	if type(obj) is list:
		position = cmds.xform(obj[0], q=True, ws=True, rp=True)[0]

	else:
		position = cmds.xform(obj, q=True, ws=True, rp=True)[0]

	if 'e' in str(position):
		return componentType.center

	else:

		if position > 0:
			return componentType.left

		elif position < 0:
			return componentType.right

		elif position == 0:
			if type(obj) is list:
				if len(obj) > 1:
					obj.remove(obj[0])
					newObj = []
					for o in obj:
						newObj.append(o)
					getPositionSide(newObj)
				else:
					return componentType.center
			else:
				return componentType.center


def getChild(root, typ='joint', *args):
	child = cmds.listRelatives(root, c=True, type=typ)
	if len(child) == 1:
		return child[0]


def zeroJointOrient(jnt, *args):
	for axis in ['x', 'y', 'z']:
		try:
			cmds.setAttr('{}.jointOrient{}'.format(jnt, axis.upper()), 0)
		except:
			pass
	return


def freezeTransform(obj, t=True, r=True, s=True, *args):
	if t:
		cmds.makeIdentity(obj, apply=True, t=True)
	if r:
		cmds.makeIdentity(obj, apply=True, r=True)
	if s:
		cmds.makeIdentity(obj, apply=True, s=True)
	return


class queryJoint():
	def __init__(self, jnt, *args):
		skinCluster = getConnectedObj(jnt, 'objectColorRGB')
		verts = []

		if skinCluster:
			skinInfluences = cmds.skinCluster(skinCluster, q=True, inf=True)

			for influence in skinInfluences:
				if jnt == influence:
					cmds.select(d=True)
					cmds.skinCluster(skinCluster, e=True, selectInfluenceVerts=influence)
					verts = cmds.ls(sl=True, fl=True)
					cmds.select(d=True)

		child = cmds.listRelatives(jnt, c=True, typ='joint')
		parent = cmds.listRelatives(jnt, p=True, typ='joint')

		if child:
			child = child[0]
		else:
			child = None

		if parent:
			parent = parent[0]
		else:
			parent = None

		self.child = child
		self.parent = parent
		self.skinCluster = skinCluster
		self.verts = verts


class estimateBoundsByJoint():
	def __init__(self, jnt, *args):
		self.verts = []
		self.minX = []
		self.maxX = []
		self.minY = []
		self.maxY = []
		self.minZ = []
		self.maxZ = []

		value = []
		vertDict = {}

		if cmds.objectType(jnt, isType='joint'):
			query = queryJoint(jnt)
			verts = query.verts

			if verts:
				for vert in verts:
					pos = cmds.xform(vert, ws=True, q=True, t=True)
					vertDict[str(vert)] = pos

			for axis in range(3):
				minValue = min(vertDict.iterkeys(), key=(lambda key: vertDict[key][axis]))
				maxValue = max(vertDict.iterkeys(), key=(lambda key: vertDict[key][axis]))

				value.append([vertDict[minValue], vertDict[maxValue]])

			self.verts = value
			self.minX = value[0][0]
			self.maxX = value[0][1]
			self.minY = value[1][0]
			self.maxY = value[1][1]
			self.minZ = value[2][0]
			self.maxZ = value[2][1]

		else:
			cmds.warning('Object is not a joint.')


def createJoint(obj=None, n='joint_0', *args):
	cmds.select(d=True)
	jnt = cmds.joint(n=n)

	if obj:
		snap(obj, jnt, t=True, r=True)
		freezeTransform(jnt)

	return jnt


def orientJointChain(*args):
	pass
	return


def getJointHierarchy(*args):
	return cmds.select(hi=True)


def createJointChain(selected=[], typ='bind', world=False, *args):
	selected = listCheck(selected)

	if not selected:
		selected = getSelected()

	if selected:
		jntList = []

		cmds.select(d=True)
		for obj in selected:
			jntName = '{}_{}_jnt'.format(removeJointStr(str(obj)), typ)

			jnt = cmds.joint(n=jntName)
			cmds.setAttr('{}.drawStyle'.format(jnt), 2)

			snap(obj, jnt, t=True, r=True)

			if cmds.objectType(obj, isType='joint'):
				radius = cmds.getAttr('{0}.radius'.format(obj))
				cmds.setAttr('{}.radius'.format(jnt), radius)

			jntList.append(jnt)
			cmds.select(d=True)

		for jnt in jntList:
			i = jntList.index(jnt)
			freezeTransform(jnt)

			if i != 0:
				if not world:
					cmds.parent(jnt, jntList[i - 1])

		return jntList

	else:
		return []


def createBindChain(selected, *args):
	selected = listCheck(selected)
	bindJnt = createJointChain(selected, typ=componentType.bind)
	for jnt in bindJnt:
		i = bindJnt.index(jnt)
		cmds.parentConstraint(jnt, selected[i], mo=True)
	return bindJnt


def jointHierarchy(root, jointList=[], *args):
	if not jointList:
		jointList = []

	children = cmds.listRelatives(root, c=True, type='joint')

	if children:
		if len(children) == 1:
			if children[0] not in jointList:
				jointList.append(children[0])
				jointHierarchy(children[0], jointList)

		if root not in jointList:
			jointList.insert(0, root)
		return jointList


def sortJointHierarchy(jointList=[], *args):
	newList = []
	root = None

	if len(jointList) > 1:
		for jnt in jointList:
			parent = cmds.listRelatives(jnt, parent=True, type='joint')

			if parent:
				parent = parent[0]

				if parent == None:
					root = jnt
					break

				elif parent not in jointList:
					root = jnt
					break

		newList.append(root)

		children = cmds.listRelatives(root, c=True, type='joint')

		if children:
			for child in children:
				c = cmds.listRelatives(child, ad=True, type='joint')
				if c:
					for j in jointHierarchy(child):
						newList.append(j)

		return newList


	else:
		return jointList


def handJointHierarchy(root, *args):
	jointList = []
	children = cmds.listRelatives(root, c=True, type='joint')

	if children:
		for child in children:
			c = cmds.listRelatives(child, ad=True, type='joint')
			if c:
				jointList.append(jointHierarchy(child))

	# Sort
	if jointList:
		handsort = ['thumb', 'index', 'middle', 'ring', 'pinky']
		newList = []
		for h in handsort:
			i = handsort.index(h)

			for finger in jointList:
				if any(h in x for x in finger):
					newList.append(finger)

		jointList = newList

	return jointList


def getDistance(start, end, *args):
	if type(start) is list:
		startPos = start
	else:
		startPos = cmds.xform(start, q=True, ws=True, rp=True)

	if type(end) is list:
		endPos = end
	else:
		endPos = cmds.xform(end, q=True, ws=True, rp=True)
	distance = sqrt(
		pow((startPos[0] - endPos[0]), 2) + pow((startPos[1] - endPos[1]), 2) + pow((startPos[2] - endPos[2]), 2))
	return distance


def removeJointStr(obj, *args):
	var = str(obj)

	removeList = ['bind', 'joint', 'jnt', 'joints', 'jnts', ]
	exclude = []

	if '_' in var:

		var = var.split('_')

		for x in var:
			if x.lower() in removeList:
				exclude.append(x)

		for x in exclude:
			var.remove(x)

		newStr = str(var).replace("'", '').replace('[', '').replace(']', '').replace(' ', '').replace(',', '_')

		return newStr

	else:
		return var


def makeNurbsCurve(objects, n='curve_#', d=1, *args):
	# 1 == Linear / 3 == Curve
	pointList = []
	for obj in objects:
		if type(obj) == str or type(obj) == unicode:
			var = cmds.xform(obj, q=True, ws=True, rp=True)
		elif type(obj) == list:
			var = obj
		pointList.append(var)
	curve = cmds.curve(n=n, d=d, p=pointList)

	shape = cmds.listRelatives(curve, shapes=True)
	cmds.rename(shape, '{}Shape'.format(curve))

	return curve


def clusterCurve(curve, n='cluster', *args):
	clusterList = []
	curveCVs = cmds.ls('{0}.cv[:]'.format(curve), fl=True)
	i = 1
	for cv in curveCVs:
		clusterList.append(cmds.cluster(cv, n='{0}_{1}'.format(n, i))[1])
		i += 1

	for c in clusterList:
		cmds.setAttr('{}.v'.format(c), 0)

	return clusterList


def setOnMotionPath(selected, curve, name='motionPath', uValue=0, *args):
	# Create Nodes
	mp = cmds.createNode('motionPath', n='{}_mp'.format(name))

	mpAttr = {'follow': 1,
	          'fractionMode': 0,
	          'worldUpType': 3,
	          'frontAxis': 2,
	          'upAxis': 1,
	          }
	for attr in mpAttr:
		cmds.setAttr('{}.{}'.format(mp, attr), mpAttr[attr])

	add = []
	for x in range(3):
		a = cmds.createNode('addDoubleLinear', n='{}_add{}'.format(name, x))
		add.append(a)

	# Make Connections
	cmds.connectAttr('{}.worldSpace[0]'.format(curve), '{}.geometryPath'.format(mp), f=True)
	cmds.connectAttr('{}.rotateOrder'.format(mp), '{}.rotateOrder'.format(selected), f=True)

	i = 0
	for axis in ['x', 'y', 'z']:
		cmds.connectAttr('{}.{}Coordinate'.format(mp, axis), '{}.input2'.format(add[i]), f=True)
		cmds.connectAttr('{}.output'.format(add[i]), '{}.t{}'.format(selected, axis), f=True)
		cmds.connectAttr('{}.r{}'.format(mp, axis), '{}.r{}'.format(selected, axis), f=True)
		cmds.connectAttr('{}.transMinusRotatePivot{}'.format(selected, axis.upper()), '{}.input1'.format(add[i]))
		i += 1

	cmds.setAttr('{0}.uValue'.format(mp), uValue)

	return mp


def locOnCurve(curve, intLoc=1, n='locator', upObject='', start=False, end=False, *args):
	locList = []
	curveLength = cmds.getAttr('{0}.maxValue'.format(curve))
	step = curveLength / float(intLoc - 1) if end else curveLength / float(intLoc + 1)
	distance = 0 if start else step

	i = 1
	for loc in range(intLoc):
		# loc = cmds.spaceLocator(n='{0}_{1}'.format(n, i))[0]
		loc = cmds.group(n='{0}_{1}'.format(n, i), em=True)
		mp = setOnMotionPath(selected=loc, name='{}_motionPath'.format(loc), curve=curve, uValue=distance)
		if upObject:
			cmds.pathAnimation(mp, e=True, wut='objectRotation', wuo=upObject)
		distance += step
		i += 1
		locList.append(loc)

	return locList


def makePoleVector(ik, start, end, *args):
	poleVector = cmds.poleVectorConstraint(start, ik)
	curve = makeNurbsCurve([start, end], n='{}_curve'.format(start))

	curveCVs = cmds.ls('{0}.cv[:]'.format(curve), fl=True)
	clusters = clusterCurve(curve, n='{}Cluster'.format(curve))

	i = 0
	for par in [start, end]:
		cmds.parent(clusters[i], par)
		i += 1

	# CleanUp
	cmds.setAttr('{}.template'.format(cmds.listRelatives(curve, shapes=True)[0]), 1)

	grp = cmds.group(curve, n='{}_grp'.format(curve))
	cmds.parent(grp, start)
	cmds.setAttr('{}.inheritsTransform'.format(grp), 0)
	zeroAttrs(grp)

	return [curve, grp]


def makeAimVector(par, child, *args):
	aim = cmds.aimConstraint(par, child, mo=True, aimVector=[1, 0, 0], upVector=[0, 1, 0], worldUpType='objectrotation',
	                         worldUpVector=[0, 1, 0], worldUpObject=par)
	curve = makeNurbsCurve([par, child], n='{}_curve'.format(par))
	curveCVs = cmds.ls('{0}.cv[:]'.format(curve), fl=True)
	clusters = clusterCurve(curve, n='{}Cluster'.format(curve))

	i = 0
	for x in [par, child]:
		cmds.parent(clusters[i], x)
		i += 1

	# CleanUp
	cmds.setAttr('{}.template'.format(cmds.listRelatives(curve, shapes=True)[0]), 1)

	grp = cmds.group(curve, n='{}_grp'.format(curve))
	cmds.parent(grp, par)
	cmds.setAttr('{}.inheritsTransform'.format(grp), 0)
	zeroAttrs(grp)

	return [curve, grp]


def zeroAttrs(obj, *args):
	for attr in ['t', 'r', 's']:
		value = 0

		if attr == 's':
			value = 1

		for axis in ['x', 'y', 'z']:
			try:
				cmds.setAttr('{}.{}{}'.format(obj, attr, axis), value)
			except:
				pass


def getParentByType(obj, typ='nurbsCurve', *args):
	par = cmds.listRelatives(obj, p=True, type='transform')

	if par:
		shape = cmds.listRelatives(par, shapes=True)[0]

		if cmds.objectType(shape) == typ:
			return par[0]

		else:
			par = getParentByType(par[0], typ)

	else:
		return None


class queryIK():
	def __init__(self, obj, *args):
		ik = None
		sj = None
		ee = None
		ej = None
		par = None

		if cmds.objectType(obj) == 'joint':
			for axis in ['x', 'y', 'z']:
				x = cmds.listConnections('{}.t{}'.format(obj, axis))

				if x:
					if ee != x:
						ee = x[0]

			if ee:
				ik = cmds.listConnections('{}.handlePath'.format(ee))

				if ik:
					ik = [0]
					sj = cmds.listConnections('{}.startJoint'.format(ik))[0]
					par = getParentByType(ik, typ='nurbsCurve')
					for axis in ['x', 'y', 'z']:
						nj = cmds.listConnections('{}.t{}'.format(ee, axis))[0]
						if ej != nj:
							ej = nj

		elif cmds.objecType(ik) == 'ikHandle':
			ik = obj
			sj = cmds.listConnections('{}.startJoint'.format(ik))[0]
			ee = cmds.listConnections('{}.endEffector'.format(ik))[0]
			par = getParentByType(ik, typ='nurbsCurve')

			ej = ''
			for axis in ['x', 'y', 'z']:
				nj = cmds.listConnections('{}.t{}'.format(ee, axis))[0]
				if ej != nj:
					ej = nj

		self.ikHandle = ik
		self.ikEffector = ee
		self.startJoint = sj
		self.endJoint = ej
		self.parent = par


def getVertPosition(obj, *args):
	verts = cmds.ls('{0}.vtx[:]'.format(obj), fl=True)

	for v in verts:
		print
		cmds.xform(v, q=True, ws=True, t=True)


def createFKIK(obj, fk, ik, ctl, n='FKIK', *args):
	# Add Attribute

	if not cmds.attributeQuery(n, node=ctl, ex=True):
		cmds.addAttr(ctl, ln=n, min=0, max=1, dv=0, k=True)

	# Error Checks

	obj = listCheck(obj)
	fk = listCheck(fk)
	ik = listCheck(ik)

	# Main Loop

	pcList = []
	reList = []

	for x in obj:
		i = obj.index(x)

		if len(obj) == 1:
			pc = cmds.parentConstraint(fk, ik, x, n='{}_{}_pc1'.format(x, n), mo=True)[0]
		else:
			pc = cmds.parentConstraint(fk[i], ik[i], x, n='{}_{}_pc1'.format(x, n), mo=True)[0]
		pcAttr = cmds.parentConstraint(pc, q=True, wal=True)

		cmds.connectAttr('{}.{}'.format(ctl, n), '{}.{}'.format(pc, pcAttr[-1]), f=True)

		reverse = cmds.createNode('reverse', n='{}_{}_re1'.format(x, n))
		cmds.connectAttr('{}.{}'.format(ctl, n), '{}.inputX'.format(reverse), f=True)
		cmds.connectAttr('{}.outputX'.format(reverse), '{}.{}'.format(pc, pcAttr[0]), f=True)

		pcList.append(pc)
		reList.append(reverse)

	# Return

	return [pcList, reList, n]


def createSet(objs, n='set1', *args):
	rootQuery = queryNetwork()
	rootSet = rootQuery.set

	cmds.select(d=True)
	objs = listCheck(objs)
	set = cmds.sets(objs, name=n)

	if cmds.objExists(str(rootSet)):
		cmds.sets(set, add=rootSet)

	return set


def getLocalVecToWorldSpace(node, vec=om.MVector.kXaxisVector):
	matrix = om.MGlobal.getSelectionListByName(node).getDagPath(0).inclusiveMatrix()
	vec = (vec * matrix).normal()
	return vec


def axisVectorColinearity(node, vec):
	vec = om.MVector(vec)
	x = getLocalVecToWorldSpace(node, vec=om.MVector.kXaxisVector)
	y = getLocalVecToWorldSpace(node, vec=om.MVector.kYaxisVector)
	z = getLocalVecToWorldSpace(node, vec=om.MVector.kZaxisVector)
	return {'x': vec * x, 'y': vec * y, 'z': vec * z}


def getClosestAxisToWorld(node, axis='z'):
	if axis == 'x':
		axis = [1, 0, 0]
	elif axis == 'y':
		axis = [0, 1, 0]
	elif axis == 'z':
		axis = [0, 0, 1]
	var = axisVectorColinearity(node, axis)
	return max(var.iterkeys(), key=(lambda key: var[key]))


def getPoleVectorPosition(start, mid, end):
	start = cmds.xform(start, q=True, ws=True, t=True)
	mid = cmds.xform(mid, q=True, ws=True, t=True)
	end = cmds.xform(end, q=True, ws=True, t=True)

	startVec = om.MVector(start[0], start[1], start[2])
	midVec = om.MVector(mid[0], mid[1], mid[2])
	endVec = om.MVector(end[0], end[1], end[2])

	line = (endVec - startVec)
	point = (midVec - startVec)

	scaleVar = (line * point) / (line * line)
	projVec = line * scaleVar + startVec

	startToMid = (midVec - startVec).length()
	midToEnd = (endVec - midVec).length()
	total = startToMid + midToEnd

	poleVecPos = (midVec - projVec).normal() * total + midVec

	return poleVecPos


def createDistanceNode(start, end, n='distanceBetween1', *args):
	node = cmds.createNode('distanceBetween', n=n)

	i = 1
	for x in [start, end]:
		cmds.connectAttr('{}.worldMatrix[0]'.format(x), '{}.inMatrix{}'.format(node, i), f=True)
		cmds.connectAttr('{}.rotatePivotTranslate'.format(x), '{}.point{}'.format(node, i), f=True)
		i += 1

	distance = cmds.getAttr('{}.distance'.format(node))

	return [node, distance]


def addEmptyAttr(obj, n='customAttr', *args):
	cmds.addAttr(obj, ln=n, at='enum', en='-:', k=True)
	cmds.setAttr('{}.{}'.format(obj, n), e=True, channelBox=True)


def toggleJointLabel(*args):
	joints = cmds.ls(type='joint')

	drawList = []

	for jnt in joints:
		var = cmds.getAttr('{}.drawLabel'.format(jnt))
		drawList.append(var)

	t = drawList.count(1)
	f = drawList.count(0)

	if f > len(joints) / 2:

		# Show
		mel.eval('displayJointLabels 4;')

	else:
		# Hide
		mel.eval('displayJointLabels 3;')


def niceString(var, *args):
	newVar = ''
	i = 0
	for v in var:
		if i == 0:
			newVar = v.upper()
		else:
			if v.isupper():
				newVar = '{} {}'.format(newVar, v)
			else:
				newVar = ''.join([newVar, v])
		i += 1

	return newVar


def setEnumByString(obj, attr, value, *args):
	enumString = cmds.attributeQuery(attr, node=obj, listEnum=1)[0]
	enumList = enumString.split(':')
	index = enumList.index(value)
	cmds.setAttr('{}.{}'.format(obj, attr), index)


class jointLabel():
	def __init__(self, joints=[], isDebug=False, *args):

		self.masterDict = {}
		self.masterList = [
			'None',
			'Root',
			'COG',
			'Spine',
			'Neck',
			'Head',
			'Collar',
			'Shoulder',
			'Shoulder Bind',
			'Elbow',
			'Elbow Bind',
			'Hand',
			'Hand Bind',
			'Thumb',
			'Index Finger',
			'Middle Finger',
			'Ring Finger',
			'Pinky Finger',
			'Hip',
			'Hip Bind',
			'Knee',
			'Knee Bind',
			'Foot',
			'Foot Bind',
			'Toe',
			'Big Toe',
			'Index Toe',
			'Middle Toe',
			'Ring Toe',
			'Pinky Toe',
		]
		if joints:
			self.populate(joints)

		if isDebug:
			self.isDebug()

	def get(self, typ, side='center'):
		chain = []

		if typ == componentType.root:
			chain.append(self.masterDict['Root'][side.capitalize()][0])

		elif typ == componentType.cog:
			chain.append(self.masterDict['COG'][side.capitalize()][0])

		elif typ == componentType.hip:
			chain.append(self.masterDict['Hip'][side.capitalize()][0])

		elif typ == componentType.spine:
			chain = self.masterDict['Spine'][side.capitalize()]

		elif typ == componentType.head:
			for x in ['Neck', 'Head']:
				chain.append(self.masterDict[x][side.capitalize()][0])

		elif typ == componentType.arm:
			for x in ['Collar', 'Shoulder', 'Elbow', 'Hand']:
				chain.append(self.masterDict[x][side.capitalize()][0])

		elif typ == componentType.hand:
			for x in ['Thumb', 'Index Finger', 'Middle Finger', 'Ring Finger', 'Pinky Finger']:
				chain.append(self.masterDict[x][side.capitalize()])

		elif typ == componentType.leg:
			for x in ['Hip', 'Knee', 'Foot', 'Toe']:
				chain.append(self.masterDict[x][side.capitalize()][0])

		elif typ == componentType.foot:
			for x in ['Big Toe', 'Index Toe', 'Middle Toe', 'Ring Toe', 'Pinky Toe']:
				chain.append(self.masterDict[x][side.capitalize()][0])

		return chain

	def populate(self, joints, *args):
		joints = listCheck(joints)

		pUI = progressWindow(st='Analyzing Joints...', max=len(self.masterList) * len(joints))

		for x in self.masterList:
			leftList = []
			rightList = []
			centerList = []
			noneList = []

			for jnt in joints:

				typ = self.getType(jnt)
				if typ[0] == x:
					if typ[1] == 'Left':
						leftList.append(jnt)
					elif typ[1] == 'Right':
						rightList.append(jnt)
					elif typ[1] == 'Center':
						centerList.append(jnt)
					else:
						noneList.append(jnt)

				pUI.update()

			if pUI.cancel():
				break

			if x != 'None':
				self.masterDict[x] = {'None': noneList, 'Left': sortJointHierarchy(leftList),
				                      'Center': sortJointHierarchy(centerList),
				                      'Right': sortJointHierarchy(rightList, )}
			else:
				self.masterDict[x] = {'None': noneList, 'Left': leftList,
				                      'Center': centerList,
				                      'Right': rightList}

	def isDebug(self):
		print(json.dumps(self.masterDict, indent=8))

	def addTypeFromUI(self, index, *args):
		selected = getSelected()

		if selected:
			for obj in selected:
				side = getPositionSide(obj)

				if cmds.objectType(obj, isType='joint'):
					if self.masterList[index - 1] in ['COG', 'Shoulder Bind', 'Elbow Bind', 'Hand Bind', 'Hip Bind',
					                                  'Knee Bind', 'Foot Bind']:
						setEnumByString(obj, 'type', 'Other')
						cmds.setAttr('{}.otherType'.format(obj), self.masterList[index - 1], type='string')
					else:
						setEnumByString(obj, 'type', self.masterList[index - 1])

					setEnumByString(obj, 'side', side.capitalize())

	def getType(self, obj, *arg):
		side = cmds.getAttr('{}.side'.format(obj), asString=True)
		typ = cmds.getAttr('{}.type'.format(obj), asString=True)

		if typ == 'Other':
			typ = cmds.getAttr('{}.otherType'.format(obj), asString=True)

		return [typ, side]


def colorIndexList(*args):
	indexColor = []
	indexColor.append([0.35, 0.35, 0.35])

	for x in range(1, 32, 1):
		c = []

		for y in cmds.colorIndex(x, q=True):
			c.append(round(y, 2))

		indexColor.append(c)

	return indexColor


def presetWireColor(selected, typ, *args):
	if typ == componentType.fk:
		color = [0, 0, 1]

	elif typ == componentType.ik:
		color = [1, 0, 0]

	elif typ == componentType.center:
		color = [1, 1, 0]

	overrideColor(selected, color=color, )


def overrideColor(selected=[], color=[], reset=False, index=False, *args):
	attrList = ['useObjectColor', 'overrideEnabled', 'overrideRGBColors']

	selected = listCheck(selected)

	if not selected:
		selected = cmds.ls(sl=True)

	if selected:
		for obj in selected:
			shape = cmds.listRelatives(obj, shapes=True, f=True)

			if shape:
				shape = shape[0]

				if reset:
					for attr in attrList:
						cmds.setAttr('{0}.{1}'.format(shape, attr), 0)

				else:

					cmds.setAttr('{0}.useObjectColor'.format(shape), 0)
					cmds.setAttr('{0}.overrideEnabled'.format(shape), 1)

					if index:
						if color:

							cmds.setAttr('{0}.overrideRGBColors'.format(shape), 0)
							cmds.setAttr('{0}.overrideColor'.format(shape), color)

						else:
							for attr in attrList:
								cmds.setAttr('{0}.{1}'.format(shape, attr), 0)

					else:
						if color:
							cmds.setAttr('{0}.overrideRGBColors'.format(shape), 1)

							i = 0
							for x in ['R', 'G', 'B']:
								cmds.setAttr('{0}.overrideColor{1}'.format(shape, x), color[i])
								i += 1


#########################################################################################################################
#																														#
#																														#
#	Networks Nodes																										#
#																														#
#																														#
#########################################################################################################################


rootNetwork = componentType.character


def network(n='network', typ='', *args):
	node = cmds.createNode('network', n=n)
	cmds.addAttr(node, ln='networkType', dt='string')
	cmds.setAttr('{}.networkType'.format(node), typ, type='string', lock=True)
	cmds.addAttr(node, ln='children', dt='string')
	cmds.addAttr(node, ln='set', at='message')

	if typ != componentType.fkik:
		cmds.addAttr(node, ln='fkikNetwork', at='message')

	if typ != componentType.root:
		cmds.addAttr(node, ln='index', dv=0, at='long')
		cmds.addAttr(node, ln='side', dt='string')
		cmds.addAttr(node, ln='characterNetwork', at='message')
		cmds.addAttr(node, ln='parentNetwork', at='message')

	if typ in [componentType.arm, componentType.leg]:
		# cmds.addAttr(node, ln='index', dv=0, at='long')
		# cmds.addAttr(node, ln='side', dt='string')
		# cmds.addAttr(node, ln='side', at='enum', en='none:center:left:right')
		cmds.addAttr(node, ln='opposite', at='message')

	if typ == componentType.character:
		cmds.addAttr(node, ln='characterName', dt='string')
		cmds.addAttr(node, ln='globalScale', dv=1)
		cmds.addAttr(node, ln='cog', at='message')
		cmds.addAttr(node, ln='hip', at='message')
		cmds.addAttr(node, ln='spine', at='message')
		cmds.addAttr(node, ln='head', at='message')
	# cmds.addAttr(node, ln='arm', dt='string', m=True)
	# cmds.addAttr(node, ln='leg', dt='string', m=True)
	# cmds.addAttr(node, ln='control', dt='string', m=True)
	# cmds.addAttr(node, ln='bindJoint', dt='string', m=True)

	elif typ == componentType.cog:
		# cmds.addAttr(node, ln='control', dt='string', m=True)
		# cmds.addAttr(node, ln='bindJoint', dt='string', m=True)
		pass
	elif typ == componentType.spine:
		cmds.addAttr(node, ln='neckHead', at='message')
		cmds.addAttr(node, ln='tail', at='message')
	elif typ == componentType.collar:
		pass
	# cmds.addAttr(node, ln='side', dt='string')

	elif typ == componentType.arm:
		cmds.addAttr(node, ln='collar', at='message')
		cmds.addAttr(node, ln='hand', at='message')
	elif typ == componentType.hand:
		pass
	# cmds.addAttr(node, ln='side', dt='string')
	# cmds.addAttr(node, ln='finger', dt='string', m=True)
	elif typ == componentType.foot:
		pass
	# cmds.addAttr(node, ln='side', dt='string')
	# cmds.addAttr(node, ln='FKIK', min=0, max=1, dv=0)
	elif typ == componentType.leg:
		cmds.addAttr(node, ln='hip', at='message')
		cmds.addAttr(node, ln='foot', at='message')

	elif typ == componentType.fkik:
		cmds.addAttr(node, ln='FKIK', dv=0, min=0, max=1)
		cmds.addAttr(node, ln='ikHandle', at='message')
		cmds.addAttr(node, ln='ikPoleVector', at='message')
		cmds.addAttr(node, ln='fkPoleVector', at='message')
	# cmds.addAttr(node, ln='bindJoint', dt='string', m=True)
	# cmds.addAttr(node, ln='fkControl', dt='string', m=True)
	# cmds.addAttr(node, ln='fkJoint', dt='string', m=True)
	# cmds.addAttr(node, ln='ikControl', dt='string', m=True)
	# cmds.addAttr(node, ln='ikJoint', dt='string', m=True)

	return node


def getConnectedObj(obj, attr):
	name = '{}.{}'.format(obj, attr)

	if cmds.connectionInfo(name, id=True):
		query = cmds.listConnections(cmds.connectionInfo(name, ged=True))[0]
		return query
	else:
		query = cmds.listConnections(name)
		if query:
			query = query[0]
			return query

		else:
			return None


def addIndexValue(obj, var, *args):
	if not cmds.attributeQuery('index', node=obj, ex=True):
		cmds.addAttr(obj, ln='index', at='long', dv=var)
	else:
		cmds.setAttr('{}.index'.format(obj), var)

	return


def connectToNetwork(obj, network, ln, *args):
	objAttr = '{}.parentNetwork'.format(obj)
	networkAttr = '{}.{}'.format(network, ln)

	if not cmds.attributeQuery('parentNetwork', node=obj, ex=True):
		cmds.addAttr(obj, ln='parentNetwork', at='message')

	if cmds.attributeQuery(ln, node=network, ex=True):
		if cmds.attributeQuery(ln, node=network, m=True):
			mList = cmds.listAttr('{}.{}'.format(network, ln), m=True)
			if mList:
				i = mList.index(mList[-1]) + 1
			else:
				i = 0

			addIndexValue(obj, i)

			networkAttr = '{}.{}[{}]'.format(network, ln, i)
	else:
		cmds.addAttr(network, ln=ln, at='message')

	cmds.connectAttr(networkAttr, objAttr, force=True)

	connectToRoot(obj)

	return [objAttr, networkAttr]


def multiConnectToNetwork(objects, network, ln, *args):
	if not cmds.attributeQuery(ln, node=network, ex=True):
		cmds.addAttr(network, ln=ln, dt='string', m=True)
		i = 0
	else:
		if cmds.listAttr('{}.{}'.format(network, ln), m=True):
			i = int(cmds.listAttr('{}.{}'.format(network, ln), m=True)[-1].split('[')[-1].split(']')[0])
		else:
			i = 0

	objects = listCheck(objects)

	for x in objects:
		connectToRoot(x)

		if not cmds.attributeQuery('parentNetwork', node=x, ex=True):
			cmds.addAttr(x, ln='parentNetwork', at='message')

		cmds.connectAttr('{}.{}[{}]'.format(network, ln, i), '{}.parentNetwork'.format(x), f=True)
		addIndexValue(x, i)
		i += 1

	return


def connectToRoot(obj, *args):
	root = queryNetwork().network

	if root:
		if not cmds.attributeQuery('characterNetwork', node=obj, ex=True):
			cmds.addAttr(obj, ln='characterNetwork', at='message')
		if not getConnectedObj(obj, 'characterNetwork'):
			cmds.connectAttr('{}.children'.format(root), '{}.characterNetwork'.format(obj), f=True)
	return


def findRootNetwork(*args):
	global rootNetwork

	networks = cmds.ls(type='network')
	root = None

	if networks:
		for x in networks:
			if cmds.attributeQuery('networkType', node=x, ex=True):
				if cmds.getAttr('{}.networkType'.format(x)) == rootNetwork:
					root = x

	return root


class queryNetwork():
	def __init__(self, selected=None, typ='character', *args):

		self.characterName = None
		self.typ = typ
		self.network = None
		self.cog = None
		self.spine = None
		self.leg = None
		self.arm = None
		self.fkik = None
		self.hip = None
		self.set = None

		selected = listCheck(selected)

		if selected:
			self.getNetworkFromSelected(selected)

		else:
			if typ == componentType.character:
				self.getRoot()
			else:
				self.network = self.findNetwork(typ)

	def findNetwork(self, typ):
		networks = self.findAllNetworksByType(typ)
		node = None

		if networks:
			if len(networks) > 1:
				node = cmds.layoutDialog(t='{} Network'.format(typ.capitalize()), ui=self.networkPromptUI)
			else:
				node = networks[0]

		return node

	def findAllNetworksByType(self, typ):
		networks = cmds.ls(type='network')
		networksList = []

		if networks:
			for net in networks:
				if cmds.attributeQuery('networkType', node=net, ex=True):
					if cmds.getAttr('{}.networkType'.format(net)) == typ:
						networksList.append(net)

		return networksList

	def getRoot(self):

		# Get Root

		root = self.findNetwork(componentType.character)
		self.network = root

		# Get CharacterName
		if root:
			self.characterName = cmds.getAttr('{}.characterName'.format(root))

		# Get COG

		if root:
			self.cog = self.getConnected(root, componentType.cog)

		# Get HIP

		if root:
			self.hip = self.getConnected(root, componentType.hip)

		# Get Spine
		if root:
			self.spine = self.getConnected(root, componentType.spine)

		# Get Arm
		if root:
			self.arm = self.getConnected(root, componentType.arm)

		# Get Leg
		if root:
			self.leg = self.getConnected(root, componentType.leg)

		# Get FKIK
		if root:
			self.fkik = self.getConnected(root, componentType.fkik)

		# Get Set
		if root:
			self.set = self.getConnected(root, componentType.set)

	def networkPromptUI(self, *args):
		networks = self.findAllNetworksByType(self.typ)

		cmds.columnLayout(adj=True)
		textVar = cmds.textScrollList(append=networks)
		cmds.button(l='Select',
		            c=lambda x: cmds.layoutDialog(dismiss=str(cmds.textScrollList(textVar, q=True, si=True)[0])))
		cmds.setParent('..')

	def getConnected(self, obj, attr, *args):
		name = '{}.{}'.format(obj, attr)
		if cmds.attributeQuery(attr, node=obj, ex=True):

			if cmds.connectionInfo(name, id=True):
				query = cmds.listConnections(cmds.connectionInfo(name, ged=True))[0]
				return query
			else:
				query = cmds.listConnections(name)
				if query:
					query = query[0]
					return query

				else:
					return None
		else:
			return None

	def getNetworkFromSelected(self, selected=[], *args):
		network = []
		parent = []

		if selected:
			if len(selected) != 1:
				for obj in selected:
					networkQ = self.getConnected(obj, 'characterNetwork')
					parentQ = self.getConnected(obj, 'parentNetwork')
					if networkQ:
						if networkQ not in network:
							network.append(networkQ)
					if parentQ:
						if parentQ not in parent:
							parent.append(parentQ)
			else:
				network = self.getConnected(selected[0], 'characterNetwork')
				parent = self.getConnected(selected[0], 'parentNetwork')

		self.network = network
		self.parent = parent


#########################################################################################################################
#																														#
#																														#
#	MODULES / COMPONENTS 																								#
#																														#
#																														#
#########################################################################################################################


characterName = 'character'


class MODULE(object):
	def __init__(self, selected=None, name='character', scale=1, typ='root', index=0, *args):
		'''
		Base Class to create rig components: Bind Joints, FK, IK, & FKIK Switching.

		:param selected:    Objects to be rigged.
		:param name:        Name of rig network
		:param typ:         Component type
		:param scale:       Scale of rig controls
		:param args:        Extra argument for MayaUI
		'''

		self.selected = self.getSelected(selected)
		self.name = name
		self.scale = scale
		self.typ = typ
		self.index = index

		self.side = getPositionSide(self.selected[0]) if self.selected else 'center'

		self.bindJoint = None
		self.control = []
		self.fkJoint = None
		self.fkControl = None
		self.ikJoint = None
		self.ikControl = None
		self.ikHandle = None
		self.ikPoleVector = None
		self.fkPoleVector = None
		self.group = None
		self.fkikNetwork = None
		self.network = None
		self.set = None
		self.attrControl = None
		self.rootQuery = queryNetwork()

		self.createNetwork()

	def createName(self, suffix, index=0):
		return '{}_{}_{}{}'.format(self.typ, self.side[0].upper(), suffix, index)

	def getSelected(self, selected):
		selected = listCheck(selected)
		if not selected:
			selected = getSelected()
		return selected

	def createBindJoints(self):
		self.bindJoint = createBindChain(self.selected)

	def createFK(self, objects):
		objects = listCheck(objects)

		fk = createFKChain(objects, scale=self.scale)
		self.fkJoint = fk.joint
		self.fkControl = fk.control

		for x in self.fkControl:
			self.control.append(x[0])
			presetWireColor(x[0], typ=componentType.fk)

	def createIK(self, objects):
		objects = listCheck(objects)

		ik = createIKChain(objects, scale=self.scale, typ=self.typ)

		self.ikJoint = ik.joint
		self.ikControl = ik.control
		self.ikHandle = ik.ikHandle
		self.ikPoleVector = ik.poleVector

		for x in self.ikControl:
			self.control.append(x[0])
			presetWireColor(x[0], typ=componentType.ik)

	def createFKIK(self, objects):
		self.createFK(objects)
		self.createIK(objects)
		self.createFKPoleVector()
		self.createFKIKNetwork(objects, self.fkJoint, self.ikJoint)

		self.createAttrControl(objects[-1])

	def createFKPoleVector(self):
		fkPoleVector = cmds.group(n=self.createName('_FKPoleVector_null'), em=True)
		snap(self.ikControl[1][0], fkPoleVector, t=True, r=True)
		cmds.parent(fkPoleVector, self.fkJoint[1])
		self.fkPoleVector = fkPoleVector

	def createAttrControl(self, selected):
		if self.typ == componentType.arm:
			axis = [1, -1, 0]
		elif self.typ == componentType.leg:
			axis = [0, 2, 0]
		else:
			axis = [0, 0, 0]

		self.attrControl = control(n=self.createName('attr_ctl'), typ='lollipop', axis=axis,
		                           parent=False, scale=self.scale)

		for attr in cmds.listAttr(self.attrControl[0], k=True):
			cmds.setAttr('{}.{}'.format(self.attrControl[0], attr), lock=True, k=False, cb=False)

		cmds.addAttr(self.attrControl[0], ln='FKIK', dv=0, min=0, max=1, k=True)
		cmds.connectAttr('{}.FKIK'.format(self.attrControl[0]), '{}.FKIK'.format(self.fkikNetwork))

		snap(selected, self.attrControl[1], t=True)
		cmds.parent(self.attrControl[1], selected)

		connectToNetwork(self.attrControl[0], self.fkikNetwork, 'attributeControl')

		overrideColor(self.attrControl[0], color=[.355, 0.0, .468])

	def createFKIKNetwork(self, obj=None, fk=None, ik=None):
		fkikNet = network(n=self.createName('fkik_network'), typ=componentType.fkik)
		self.setNetworkDefaults(fkikNet)
		connectToNetwork(fkikNet, self.network, 'fkikNetwork')

		if fk and ik:
			fkik = createFKIK(obj=obj, fk=fk, ik=ik, ctl=fkikNet)
			for f in self.fkControl:
				i = self.fkControl.index(f)
				cmds.connectAttr('{}.outputX'.format(fkik[1][i]), '{}.v'.format(f[0]))

			for i in self.ikControl:
				cmds.connectAttr('{}.FKIK'.format(fkikNet), '{}.v'.format(i[0]))

		if self.bindJoint:
			multiConnectToNetwork(self.bindJoint, fkikNet, 'bindJoint')

		if self.fkControl:
			fkControl = [x[0] for x in self.fkControl]
			multiConnectToNetwork(self.fkJoint, fkikNet, 'fkJoint')
			multiConnectToNetwork(fkControl, fkikNet, 'fkControl')

		if self.ikHandle:
			connectToNetwork(self.ikHandle, fkikNet, 'ikHandle')
		# connectToNetwork(self.ikPoleVector, fkikNet, 'ikPoleVector')

		if self.fkPoleVector:
			connectToNetwork(self.fkPoleVector, fkikNet, 'fkPoleVector')

		if self.ikControl:
			ikControl = [x[0] for x in self.ikControl]
			multiConnectToNetwork(self.ikJoint, fkikNet, 'ikJoint')
			multiConnectToNetwork(ikControl, fkikNet, 'ikControl')

		self.fkikNetwork = fkikNet

	def createNetwork(self):
		self.network = network(n=self.createName('network'), typ=self.typ)
		self.setNetworkDefaults(self.network)

	def setNetworkDefaults(self, network):
		cmds.setAttr('{}.index'.format(network), self.index)
		cmds.setAttr('{}.side'.format(network), self.side, type='string', lock=True)

	def createSet(self):
		self.set = createSet(self.control, n=self.createName('control_set'))
		connectToNetwork(self.set, self.network, componentType.set)


class ROOT(MODULE):

	def __init__(self, selected=None, name='character', scale=1, *args):
		super(ROOT, self).__init__(selected=selected, name=name, scale=scale, typ=componentType.character)

		self.createControls()
		self.updateNetwork()

	def determineControlScale(self):
		self.parent = False

		if self.selected:
			self.parent = True

			children = cmds.listRelatives(self.selected[0], ad=True)

			posList = []

			if children:
				for child in children:
					if cmds.objectType(child, isType='joint'):
						pos = cmds.xform(child, q=True, ws=True, rp=True)
						posList.append(pos[1])
			if posList:
				self.scale = int(max(posList) / 2)

	def createControls(self):
		self.determineControlScale()

		# Controls

		ctl = control(self.selected, n='root_ctl', typ='root', r=False, scale=self.scale + 2, parent=False)
		offset = control(self.selected, n='root_offset_ctl', typ='center', r=False, scale=self.scale - 2,
		                 parent=self.parent)
		presetWireColor([ctl[0], offset[0]], typ=componentType.center)
		cmds.parent(offset[1], ctl[0])

		# Global Scale

		cmds.addAttr(ctl[0], ln='globalScale', dv=1)
		cmds.setAttr('{}.globalScale'.format(ctl[0]), k=False, channelBox=True)

		for axis in ['x', 'y', 'z']:
			cmds.connectAttr('{}.globalScale'.format(ctl[0]), '{}.s{}'.format(ctl[0], axis))

			if self.selected:
				cmds.connectAttr('{}.globalScale'.format(ctl[0]), '{}.s{}'.format(self.selected[0], axis))

			cmds.setAttr('{}.s{}'.format(ctl[0], axis), k=False, channelBox=False, lock=True)
			cmds.setAttr('{}.s{}'.format(offset[0], axis), k=False, channelBox=False, lock=True)

		cmds.connectAttr('{}.globalScale'.format(ctl[0]), '{}.globalScale'.format(self.network))

		# Master Group
		self.group = createGroup(ctl[1], n='{}_RIG'.format(self.name))

		# Return
		self.fkControl = [ctl, offset]
		for x in self.fkControl:
			self.control.append(x[0])

	def updateNetwork(self):
		cmds.setAttr('{}.characterName'.format(self.network), self.name, type='string')
		self.createSet()
		multiConnectToNetwork(self.control, self.network, 'control')


class COG(MODULE):

	def __init__(self, selected=None, name='cog', scale=1, *args):
		super(COG, self).__init__(selected=selected, name=name, scale=scale, typ=componentType.cog)

		if self.selected:
			self.createControls()
			self.updateNetwork()

	def determineControlScale(self):
		self.scale = cmds.xform(self.selected[0], q=True, ws=True, rp=True)[1] / 4 + 1

	def createControls(self):
		self.determineControlScale()
		self.createBindJoints()

		ctl = control(self.bindJoint, n='cog_ctl', typ='center', r=False, parent=False, scale=self.scale, nest=True)
		presetWireColor(ctl, typ=componentType.center)

		self.fkControl = ctl
		self.control.append(ctl[0])

	def updateNetwork(self):
		self.createSet()

		if self.rootQuery.network:
			connectToNetwork(self.network, self.rootQuery.network, componentType.cog)
			rootCtl = getConnectedObj(self.rootQuery.network, 'control[0]')
			cmds.parent(self.fkControl[1], rootCtl)

		multiConnectToNetwork(self.control, self.network, 'control')
		multiConnectToNetwork(self.bindJoint, self.network, 'bindJoint')


class HIP(MODULE):

	def __init__(self, selected=None, name='hip', scale=1, *args):
		super(HIP, self).__init__(selected=selected, name=name, scale=scale, typ=componentType.hip)

		if self.selected:
			self.createControls()
			self.updateNetwork()

	def determineControlScale(self):
		self.scale = cmds.xform(self.selected[0], q=True, ws=True, rp=True)[1] / 4

	def createControls(self):
		self.determineControlScale()
		self.createBindJoints()

		ctl = control(self.bindJoint, n='hip_ctl', typ='circle', r=False, parent=False, scale=self.scale, nest=True)
		presetWireColor(ctl, typ=componentType.center)

		self.fkControl = ctl
		self.control.append(ctl[0])

	def updateNetwork(self):
		self.createSet()

		if self.rootQuery.network:
			connectToNetwork(self.network, self.rootQuery.network, componentType.hip)

		if self.rootQuery.cog:
			cog = getConnectedObj(self.rootQuery.cog, 'control[0]')

			if cog:
				cmds.parent(self.fkControl[1], cog)

		multiConnectToNetwork(self.control, self.network, 'control')
		multiConnectToNetwork(self.bindJoint, self.network, 'bindJoint')


class SPINE(MODULE):
	def __init__(self, selected=None, name='spine', scale=1, *args):
		super(SPINE, self).__init__(selected=selected, name=name, scale=scale, typ=componentType.spine)

		if self.selected:
			self.createControls()
			self.updateNetwork()

	def determineControlScale(self):
		bound = estimateBoundsByJoint(self.selected[0])
		if bound:
			self.scale = bound.maxX[0]

	def createControls(self):
		self.determineControlScale()
		self.createBindJoints()
		self.createFK(self.bindJoint)

		i = 0
		for jnt in self.fkJoint:
			cmds.parentConstraint(jnt, self.bindJoint[i], mo=True)
			i += 1

	def updateNetwork(self):
		self.createSet()
		self.createFKIKNetwork()

		if self.rootQuery.network:
			connectToNetwork(self.network, self.rootQuery.network, componentType.spine)

		if self.rootQuery.cog:
			cog = getConnectedObj(self.rootQuery.cog, 'control[0]')
			cogBind = getConnectedObj(self.rootQuery.cog, 'bindJoint[0]')

			if cog:
				cmds.parent(self.fkControl[0][1], cog)
				cmds.parent(self.bindJoint[0], cogBind)


class HEAD(MODULE):
	def __init__(self, selected=None, name='head', scale=1, *args):
		super(HEAD, self).__init__(selected=selected, name=name, scale=scale, typ=componentType.head)

		if self.selected:
			self.createControls()
			self.createFKIKNetwork()
			self.createFKIK()
			self.updateNetwork()

	def createControls(self):
		self.createBindJoints()
		self.createFK(self.bindJoint)
		cmds.parentConstraint(self.fkControl[0][0], self.bindJoint[0])
		self.createIK(self.bindJoint)

	def createIK(self, objects):
		cmds.select(d=True)

		distance = cmds.xform(objects[-1], q=True, ws=True, rp=True)[1] / 2

		ikJnt = cmds.joint(n='{}_ik_jnt'.format(removeJointStr(objects[-1])))
		cmds.setAttr('{}.v'.format(ikJnt), 0)
		ikCtl = control(n='{}_ik_ctl'.format(removeJointStr(objects[-1])), axis=[1, 0, 0], t=False, r=False)

		snap(objects[-1], ikJnt, t=True, r=True)
		snap(objects[-1], ikCtl[-1], t=True, r=False)
		cmds.xform(ikCtl[-1], ws=True, t=[0, 0, distance], r=True)

		cmds.parent(ikJnt, self.fkControl[0][0])
		makeAimVector(ikCtl[0], ikJnt)

		presetWireColor(ikCtl[0], typ=componentType.ik)

		self.ikJoint = [ikJnt]
		self.ikControl = [ikCtl]

	def createFKIK(self):
		fkik = createFKIK(self.bindJoint[-1], self.fkJoint[-1], self.ikJoint[-1], ctl=self.fkikNetwork)
		cmds.connectAttr('{}.outputX'.format(fkik[1][0]), '{}.v'.format(self.fkControl[-1][1]))
		cmds.connectAttr('{}.{}'.format(self.fkikNetwork, fkik[2]), '{}.v'.format(self.ikControl[0][1]))

	def updateNetwork(self):
		self.createSet()

		if self.rootQuery.network:
			connectToNetwork(self.network, self.rootQuery.network, componentType.head)

			rootCtl = getConnectedObj(self.rootQuery.network, 'control[0]')

			if rootCtl:
				cmds.parent(self.ikControl[0][1], rootCtl)

			if self.rootQuery.cog:
				cog = getConnectedObj(self.rootQuery.cog, 'control[0]')
				if cog:
					createLocalWorld(self.fkControl[-1][0], local=self.bindJoint[0], world=cog)

			if self.rootQuery.spine:
				spineFKIK = getConnectedObj(self.rootQuery.spine, 'fkikNetwork')
				spineJnt = cmds.listConnections('{}.bindJoint'.format(spineFKIK))

				if spineJnt:
					cmds.parent(self.fkControl[0][-1], self.bindJoint[0], spineJnt[-1])


class COLLAR(MODULE):
	def __init__(self, selected=None, name='collar', scale=1, index=0, *args):
		super(COLLAR, self).__init__(selected=selected, name=name, scale=scale, index=index, typ=componentType.collar)

		if self.selected:
			self.bindJoint = [self.selected[0]]
			self.createControls()
			self.createFKIKNetwork(self.bindJoint[0], self.fkJoint[0], self.ikJoint[0])
			self.updateNetwork()

	def createControls(self):
		self.createFK(self.bindJoint[0])
		self.createIK(self.selected)
		self.createFKPoleVector()

	def createIK(self, selected):
		ikJnt = createJointChain(selected, typ='ik_aux', world=False)
		ikCtl = control(selected[1], n='{}_ik_ctl'.format(removeJointStr(selected[0])), axis=[1, 0, 0],
		                parent=False)
		ikHandle = cmds.ikHandle(n='collar_{}_ikHandle'.format(self.side[0].upper()), sj=ikJnt[0], ee=ikJnt[1],
		                         sol='ikSCsolver')[0]
		cmds.setAttr('{}.v'.format(ikHandle), 0)
		cmds.parent(ikHandle, ikCtl[0])

		presetWireColor(ikCtl[0], componentType.ik)

		self.control.append(ikCtl[0])

		self.ikJoint = ikJnt
		self.ikControl = [ikCtl]
		self.ikHandle = ikHandle

	def createFKPoleVector(self):
		fkPoleVector = cmds.group(n='{}_fkPoleVector_null'.format(self.fkJoint[0]), em=True)
		snap(self.ikJoint[1], fkPoleVector, t=True, r=True)
		cmds.parent(fkPoleVector, self.fkJoint[0])

		self.fkPoleVector = fkPoleVector

	def updateNetwork(self):
		if self.rootQuery.network:
			if self.rootQuery.cog:
				cog = cmds.listConnections('{}.control[0]'.format(self.rootQuery.cog))
				if cog:
					cmds.parent(self.ikControl[0][1], cog)

			if self.rootQuery.spine:
				spineFKIK = getConnectedObj(self.rootQuery.spine, 'fkikNetwork')
				spineJnt = cmds.listConnections('{}.bindJoint'.format(spineFKIK))
				if spineFKIK:
					cmds.parent(self.fkControl[0][1], self.ikJoint[0], spineJnt[-1])


class ARM(MODULE):
	def __init__(self, selected=None, name='arm', scale=1, index=0, *args):
		super(ARM, self).__init__(selected=selected, name=name, scale=scale, index=index, typ=componentType.arm)

		if self.selected:
			self.createControls()
			self.updateNetwork()

	def createControls(self):
		self.createBindJoints()

		if len(self.bindJoint) == 4:
			self.createFKIK([self.bindJoint[1], self.bindJoint[2], self.bindJoint[3]])
			self.createCollar(self.bindJoint[0], self.bindJoint[1])

		elif len(self.bindJoint) == 3:
			self.createFKIK(self.bindJoint)

		self.createHand()

	def createCollar(self, start, end):
		collar = COLLAR([start, end])
		presetWireColor(collar.fkControl[0], componentType.fk)
		presetWireColor(collar.ikControl[0], componentType.ik)

		connectToNetwork(collar.network, self.network, 'collar')
		cmds.parent(self.fkControl[0][1], self.ikControl[0][1], collar.bindJoint[0])

		self.control = self.control + collar.control

		if self.rootQuery.cog:
			cog = cmds.listConnections('{}.control'.format(self.rootQuery.cog))[0]
			if cog:
				createLocalWorld(self.fkControl[0][0], local=collar.bindJoint[0], world=cog)

		cmds.addAttr(self.attrControl[0], ln='collarFKIK', dv=0, min=0, max=1, k=True)
		cmds.connectAttr('{}.collarFKIK'.format(self.attrControl[0]), '{}.FKIK'.format(collar.fkikNetwork))

	def createHand(self):
		hand = HAND(self.selected[-1])
		connectToNetwork(hand.network, self.network, 'hand')

		self.control = self.control + hand.control

		cmds.parent(hand.group, [x[0] for x in hand.bindJoint], self.bindJoint[-1])

	def updateNetwork(self):
		self.createSet()

		if self.rootQuery.network:
			connectToNetwork(self.network, self.rootQuery.network, componentType.arm)
			rootCtl = cmds.listConnections('{}.control'.format(self.rootQuery.network))

			if rootCtl:
				cmds.parent(self.ikControl[1][1], self.ikControl[2][1], rootCtl[0])

			if self.rootQuery.spine:
				spineFKIK = getConnectedObj(self.rootQuery.spine, 'fkikNetwork')
				spineJnt = cmds.listConnections('{}.bindJoint'.format(spineFKIK))

				if spineJnt:
					cmds.parent(self.bindJoint[0], spineJnt[-1])


class LEG(MODULE):
	def __init__(self, selected=None, name='leg', scale=1, *args):
		super(LEG, self).__init__(selected=selected, name=name, scale=scale, typ=componentType.leg)

		if self.selected:
			self.createControls()
			self.updateNetwork()

	def createControls(self):
		self.createBindJoints()

		if len(self.bindJoint) == 4:
			self.createFK(self.bindJoint)
			self.createIKLeg([self.bindJoint[0], self.bindJoint[1], self.bindJoint[2]])
			self.createFKIKNetwork(self.bindJoint, self.fkJoint, self.ikJoint)
			self.createAttrControl(self.bindJoint[2])

		elif len(self.bindJoint) == 3:
			self.createFKIK(self.bindJoint)

	def createIKLeg(self, objects):
		self.createIK(objects)

		ballJnt = createJointChain(self.bindJoint[-1], typ=componentType.ik, world=True)[0]
		cmds.parent(ballJnt, self.ikJoint[-1])
		self.ikJoint.append(ballJnt)

		self.createFoot()

	def createFoot(self):
		foot = createIKFootPivot(n=self.createName('ik_footPivot'), ik=self.ikHandle,
		                         start=self.selected[2], end=self.ikJoint[-1], ctl=self.ikControl[-1][0])

	def updateNetwork(self):
		cmds.setAttr('{}.FKIK'.format(self.attrControl[0]), 1)

		if self.rootQuery.network:
			connectToNetwork(self.network, self.rootQuery.network, componentType.leg)
			rootCtl = cmds.listConnections('{}.control'.format(self.rootQuery.network))

			if rootCtl:
				cmds.parent(self.ikControl[1][1], self.ikControl[2][1], rootCtl[0])

			cogCtl = None
			if self.rootQuery.cog:
				cogCtl = cmds.listConnections('{}.control'.format(self.rootQuery.cog))

			if self.rootQuery.hip:
				hipCtl = cmds.listConnections('{}.control'.format(self.rootQuery.hip))
				hipBind = getConnectedObj(self.rootQuery.hip, 'bindJoint[0]')

				if hipBind:
					cmds.parent(self.bindJoint[0], hipBind)

				if hipCtl:
					cmds.parent(self.ikControl[0][1], self.fkControl[0][1], hipCtl[0])

					if cogCtl:
						createLocalWorld(self.fkControl[0][0], local=hipCtl[0], world=cogCtl[0])


class HAND(MODULE):
	def __init__(self, selected=None, name='hand', scale=1, index=0, *args):
		super(HAND, self).__init__(selected=selected, name=name, scale=scale, index=0, typ=componentType.hand)

		self.handDict = {componentType.thumb: [],
		                 componentType.index: [],
		                 componentType.middle: [],
		                 componentType.ring: [],
		                 componentType.pinky: [],
		                 }

		if self.selected:
			self.createControls()

	def createControls(self):
		self.bindJoint = []

		cmds.addAttr(self.network, ln='finger', dt='string', m=True)

		jointChain = self.getJointOrder()
		if jointChain:
			masterGrp = cmds.group(n=self.createName('rig_fk_ctl_grp'), em=True)
			snap(self.selected[0], masterGrp, t=True, r=True)

			i = 0
			for chain in jointChain:
				fingerRig = FINGER(jointChain[chain], index=i)
				connectToNetwork(fingerRig.network, self.network, 'finger')

				self.control = self.control + fingerRig.control
				self.bindJoint.append(fingerRig.bindJoint)
				cmds.parent(fingerRig.fkControl[0][1], masterGrp)
				i += 1

			self.group = masterGrp

	def getJointOrder(self):
		return self.getJointOrderByName() if not self.getJointOrderByLabel() else self.getJointOrderByLabel()

	def getJointOrderByName(self):
		chain = handJointHierarchy(self.selected)

		handDict = self.handDict

		for x in self.handDict:
			for jnt in chain:
				for j in jnt:
					if x in j:
						handDict[x] = jnt
						break

		return handDict

	def getJointOrderByLabel(self):
		chain = handJointHierarchy(self.selected)
		handDict = self.handDict

		newChain = []
		for c in chain:
			for x in c:
				newChain.append(x)

		newChain = jointLabel(newChain).get(self.typ, self.side)

		i = 0
		for x in self.handDict:
			handDict[x] = newChain[i]
			i += 1

		return handDict


class FINGER(MODULE):
	def __init__(self, selected=None, name='finger', scale=1, index=0, *args):
		super(FINGER, self).__init__(selected=selected, name=name, scale=scale, index=index, typ=componentType.finger)

		if self.selected:
			self.createControls()
			self.updateNetwork()

	def createControls(self):
		self.determineControlScale(self.selected[-1])
		self.createBindJoints()
		self.createFK(self.bindJoint)

		i = 0
		for jnt in self.fkJoint:
			cmds.parentConstraint(jnt, self.bindJoint[i], mo=True)
			i += 1

	def determineControlScale(self, selected):
		bound = estimateBoundsByJoint(selected)
		if bound:
			self.scale = getDistance(bound.maxZ, bound.minZ) / 2

	def updateNetwork(self):
		self.createFKIKNetwork()


class NOODLE(MODULE):
	def __init__(self, selected=None, name='limb', typ=componentType.noodle, scale=1, *args):
		super(NOODLE, self).__init__(selected=selected, name=name, scale=scale, typ=typ)

		if self.selected:

			if len(self.selected) % 2 == 0:
				cmds.warning('Need Odd Number of Joints.')

			else:
				self.midNum = (len(self.selected) / 2) + 1
				self.mainControl = None

				self.createControls()
				self.createConnections()
				self.updateNetwork()

	def createControls(self):
		self.bindJoint = self.createBindJoints(self.selected)
		self.createBindControls()
		self.createMainControls()

		upperList = [self.mainControl[0][0], self.mainControl[1][0], self.mainControl[2][0]]
		lowerList = [self.mainControl[2][0], self.mainControl[3][0], self.mainControl[4][0]]

		self.upperBound = self.createCurveBound(upperList, name='upperBound_curve1', amount=self.midNum)
		self.lowerBound = self.createCurveBound(lowerList, name='lowerBound_curve1', amount=self.midNum)

	# self.smoothBound = self.createCurveBound([x[0] for x in self.mainControl], name='smoothBound_curve1',
	#                                         amount=len(self.bindJoint))

	def createBindControls(self):
		for jnt in self.bindJoint:
			ctl = control(jnt, n='{}_ctl'.format(removeJointStr(jnt)), typ='circle', axis=[1, 0, 0], nest=True,
			              parent=False)
			self.control.append(ctl)

	def createMainControls(self):
		start = self.bindJoint[0]
		mid = self.bindJoint[len(self.bindJoint) / 2]
		end = self.bindJoint[-1]

		# Main Controls

		mainCtlList = []
		i = 0
		for jnt in [start, mid, end]:
			ctl = control(jnt, n=self.createName('main_{}_ctl'.format(i)),
			              typ='square',
			              axis=[1, 0, 0], parent=False)
			mainCtlList.append(ctl)
			i += 1

		# Main Curve
		self.mainBound = self.makeCurve(selected=[x[0] for x in mainCtlList],
		                                name=self.createName('main_curve1'), amount=len(self.bindJoint))

		# Int Controls

		intCtlList = []
		i = 0
		for obj in ['upper', 'lower']:
			ctl = control(n=self.createName('{}Bound_{}_ctl'.format(obj, i)),
			              typ='square',
			              axis=[1, 0, 0])
			cmds.delete(cmds.pointConstraint(mainCtlList[i][1], mainCtlList[i + 1][1], ctl[1]))
			snap(mainCtlList[i][1], ctl[1], r=True, t=False)
			intCtlList.append(ctl)
			i += 1

		mainCtlList.insert(1, intCtlList[0])
		mainCtlList.insert(3, intCtlList[1])

		self.mainControl = mainCtlList

	def createCurveBound(self, selected, name, amount, parent=True, start=True, end=True, d=2):
		return self.makeCurve(selected,
		                      name=self.createName(name),
		                      amount=amount,
		                      parent=parent,
		                      start=start,
		                      end=end,
		                      d=d)

	def createBindJoints(self, selected):
		bindJoints = createJointChain(selected, typ=self.typ, world=True)

		i = 0
		for jnt in bindJoints:
			cmds.parentConstraint(jnt, selected[i], mo=True)
			cmds.scaleConstraint(jnt, selected[i], mo=True)
			i += 1

		return bindJoints

	class makeCurve(object):
		def __init__(self, selected, name, amount, upObject=None, parent=True, start=True, end=True, d=1):
			curve = makeNurbsCurve(selected, n=name, d=d)
			clusters = clusterCurve(curve, n='{}_cluster'.format(curve))
			null = locOnCurve(curve=curve, intLoc=amount, n='{}_null'.format(curve), upObject=upObject, start=start,
			                  end=end)
			grp = cmds.group(null, n='{}_null_grp'.format(name))

			if parent:
				i = 0
				for c in clusters:
					cmds.parent(c, selected[i])
					i += 1

			self.curve = curve
			self.cluster = clusters
			self.null = null
			self.group = grp

	def createConnections(self):

		cmds.addAttr(self.network, ln='smooth', at='double', dv=0, min=0, max=1)

		for i in [self.midNum / 2, self.midNum]:
			cmds.parent(self.mainControl[i][1], self.mainBound.null[i])

		del (self.upperBound.null)[-1]

		i = 0
		for null in self.upperBound.null + self.lowerBound.null:
			cmds.parent(self.control[i][1], null)
			i += 1

	def updateNetwork(self):
		pass


class createFKChain():
	def __init__(self, objs, scale=1, *args):

		self.control = None
		self.joint = None

		jointList = []
		controlList = []

		objs = createJointChain(objs, typ='fk', world=True)

		for obj in objs:
			ctl = control(obj, n='{}_ctl'.format(removeJointStr(obj)), axis=[1, 0, 0], parent=False, nest=True,
			              scale=scale)
			controlList.append(ctl)

		i = 0
		for x in controlList:
			if i != 0:
				cmds.parent(x[-1], controlList[i - 1][0])
			i += 1

		self.joint = objs
		self.control = controlList


class createIKChain():
	def __init__(self, objs, typ=componentType.limb, scale=1, jnt=True, stretch=True, *args):

		if typ == componentType.arm:
			axis = [1, 0, 0]
		elif typ == componentType.leg:
			axis = [0, 0, 0]
		else:
			axis = [1, 0, 0]

		side = getPositionSide(objs)
		prefix = '{}_{}'.format(typ, side[0].upper())

		jointList = []
		controlList = []

		if jnt:
			objs = createJointChain(objs, typ='ik', world=False)

		start = objs[0]
		mid = objs[1]
		end = objs[2]

		# Controls

		for obj in [start, mid, end]:
			ctl = control(obj, n='{}_ctl'.format(removeJointStr(obj)), axis=axis, r=False, parent=False, scale=scale)
			controlList.append(ctl)

		# Hip Constraint

		# cmds.pointConstraint(controlList[0][0], start, mo=True)
		cmds.parent(start, controlList[0][0])

		# Create IK

		if typ == componentType.leg:
			cmds.setAttr('{}.ty'.format(controlList[-1][-1]), 0)

		handle = \
			cmds.ikHandle(name='{}_{}_ikHandle_0'.format(typ, side[0].upper()), sj=start, ee=end, sol='ikRPsolver')[0]
		cmds.parent(handle, controlList[-1][0])
		cmds.orientConstraint(handle, end, mo=True)
		cmds.setAttr('{}.v'.format(handle), 0)

		distance = getDistance(start, end)

		pvPos = getPoleVectorPosition(start, mid, end)
		cmds.xform(controlList[1][1], ws=True, t=pvPos)

		# PoleVector

		pv = makePoleVector(handle, controlList[1][0], mid)

		# Create Stretch
		'''
		sCtl = controlList[-1][0]

		addEmptyAttr(sCtl, n='stretch')
		cmds.addAttr(sCtl, ln='addStretch', dv=0, k=True)
		cmds.addAttr(sCtl, ln='autoStretch', dv=0, min=0, max=1, k=True)
		cmds.addAttr(sCtl, ln='pin', dv=0, min=-10, max=10, k=True)
		cmds.addAttr(sCtl, ln='slide', dv=0, min=-10, max=10, k=True)

		stretchLoc = cmds.spaceLocator(n='{}_stretch_loc'.format(sCtl))[0]
		cmds.setAttr('{}.v'.format(stretchLoc), 0)
		snap(end, stretchLoc, r=True, t=True)
		cmds.parent(stretchLoc, sCtl)
		distanceA = getDistance(objs[0], objs[1])
		distanceB = getDistance(objs[1], objs[2])

		# Auto / Add Stretch
		disA = createDistanceNode(controlList[0][0], stretchLoc, n='{}_distance_0'.format(prefix))[0]

		amd = cmds.createNode('multiplyDivide', n='{}_autoStretch_ik_md_0'.format(prefix))
		cmds.setAttr('{}.operation'.format(amd), 2)
		cmds.setAttr('{}.input2X'.format(amd), distanceA + distanceB)
		cmds.connectAttr('{}.distance'.format(disA), '{}.input1X'.format(amd))

		aco = cmds.createNode('condition', n='{}_autoStretch_ik_cn_0'.format(prefix))
		cmds.setAttr('{}.operation'.format(aco), 2)
		cmds.connectAttr('{}.distance'.format(disA), '{}.firstTerm'.format(aco))
		cmds.connectAttr('{}.input2X'.format(amd), '{}.secondTerm'.format(aco))
		cmds.connectAttr('{}.outputX'.format(amd), '{}.colorIfTrueR'.format(aco))

		asr = cmds.createNode('setRange', n='{}_autoStretch_ik_sr_0'.format(prefix))
		cmds.setAttr('{}.minX'.format(asr), 1)
		cmds.setAttr('{}.oldMaxX'.format(asr), 1)
		cmds.connectAttr('{}.autoStretch'.format(sCtl), '{}.valueX'.format(asr))
		cmds.connectAttr('{}.outColorR'.format(aco), '{}.maxX'.format(asr))

		apm = cmds.createNode('plusMinusAverage', n='{}_autoStretch_ik_pm_0'.format(prefix))
		cmds.connectAttr('{}.addStretch'.format(sCtl), '{}.input3D[0].input3Dx'.format(apm))
		cmds.connectAttr('{}.addStretch'.format(sCtl), '{}.input3D[0].input3Dy'.format(apm))
		cmds.connectAttr('{}.outValueX'.format(asr), '{}.input3D[1].input3Dx'.format(apm))
		cmds.connectAttr('{}.outValueX'.format(asr), '{}.input3D[1].input3Dy'.format(apm))

		# Sliding Stretch

		slm = cmds.createNode('multiplyDivide', n='{}_slide_ik_md_0'.format(prefix))
		cmds.setAttr('{}.input2X'.format(slm), -1)
		cmds.connectAttr('{}.slide'.format(sCtl), '{}.input1X'.format(slm))

		slc = cmds.createNode('condition', n='{}_slide_ik_cn_0'.format(prefix))
		cmds.setAttr('{}.operation'.format(slc), 2)
		cmds.connectAttr('{}.slide'.format(sCtl), '{}.firstTerm'.format(slc))
		cmds.connectAttr('{}.slide'.format(sCtl), '{}.colorIfTrueG'.format(slc))
		cmds.connectAttr('{}.slide'.format(sCtl), '{}.colorIfFalseG'.format(slc))
		cmds.connectAttr('{}.outputX'.format(slm), '{}.colorIfTrueR'.format(slc))
		cmds.connectAttr('{}.outputX'.format(slm), '{}.colorIfFalseR'.format(slc))

		cmds.connectAttr('{}.outColorR'.format(slc), '{}.input3D[2].input3Dx'.format(apm))
		cmds.connectAttr('{}.outColorG'.format(slc), '{}.input3D[2].input3Dy'.format(apm))

		# Pinning / Locking

		disB = createDistanceNode(controlList[0][0], controlList[1][0], n='{}_distance_0'.format(prefix))[0]
		disC = createDistanceNode(controlList[1][0], stretchLoc, n='{}_distance_0'.format(prefix))[0]

		pmd = cmds.createNode('multiplyDivide', n='{}_pin_ik_md_0'.format(prefix))
		cmds.setAttr('{}.input2X'.format(pmd), distanceA)
		cmds.setAttr('{}.input2Y'.format(pmd), distanceB)
		cmds.connectAttr('{}.distance'.format(disB), '{}.input1X'.format(pmd))
		cmds.connectAttr('{}.distance'.format(disC), '{}.input1Y'.format(pmd))

		pbc = cmds.createNode('blendColors', n='{}_pin_ik_bc_0'.format(prefix))
		cmds.connectAttr('{}.pin'.format(sCtl), '{}.blender'.format(pbc))
		cmds.connectAttr('{}.outputX'.format(pmd), '{}.color1R'.format(pbc))
		cmds.connectAttr('{}.outputY'.format(pmd), '{}.color1G'.format(pbc))

		cmds.connectAttr('{}.output3Dx'.format(apm), '{}.color2R'.format(pbc))
		cmds.connectAttr('{}.output3Dy'.format(apm), '{}.color2G'.format(pbc))

		# Scale

		cmds.connectAttr('{}.outputR'.format(pbc), '{}.sx'.format(objs[0]))
		cmds.connectAttr('{}.outputG'.format(pbc), '{}.sx'.format(objs[1]))
		'''
		# Return
		self.joint = objs
		self.ikHandle = handle
		self.poleVector = pv
		self.control = controlList


class createIKFootPivot():
	def __init__(self, n='ik_footPivot', ik=None, start=None, end=None, ctl=None, *args):

		side = getPositionSide(start)

		# Query IK

		if not ik:
			ik = queryIK(start).ikHandle

		# Create Nulls

		grpList = []

		for grp in ['inner', 'outter', 'heel', 'toe', 'ball']:
			g = cmds.group(n='{}_{}_null'.format(n, grp), em=True)
			grpList.append(g)

		i = 0
		for g in grpList:
			if i != 0:
				cmds.parent(g, grpList[i - 1])
			i += 1

		masterGrp = cmds.group(grpList[0], n='{}_grp'.format(n))

		# Toe Raise

		toeRaise = cmds.group(n='{}_toeRaise_null'.format(n), em=True)
		cmds.parent(toeRaise, grpList[3])
		grpList.append(toeRaise)

		# Pivot Locations

		snap(start, masterGrp, t=True, r=False)
		loc = cmds.spaceLocator()
		snap(end, loc, t=True, r=False)
		cmds.delete(
			cmds.aimConstraint(loc, masterGrp, aimVector=[0, 0, 1], upVector=[0, 1, 0], worldUpType='vector',
			                   worldUpVector=[0, 1, 0], skip=['x', 'z']))
		cmds.delete(loc)

		bounds = estimateBoundsByJoint(start)

		if bounds.verts:
			if side == componentType.right:
				grpList[0], grpList[1] = grpList[1], grpList[0]

			i = 0
			for b in [bounds.minX, bounds.maxX, bounds.minZ, bounds.maxZ]:
				cmds.xform(grpList[i], ws=True, rp=[b[0], 0, b[2]])
				i += 1

		for grp in [grpList[4], grpList[5]]:
			snap(end, grp, t=True, r=False)
			freezeTransform(grp)

		# Ball Control

		ballCtl = control(end, n='{}_ball_ctl'.format(n), axis=[1, 0, 0], parent=False)
		cmds.parent(ballCtl[1], grpList[4])

		# Toe Control

		toeCtl = control(grpList[3], n='{}_toe_ctl'.format(n), axis=[1, 0, 0], parent=False)
		cmds.parent(toeCtl[1], grpList[5])
		snap(end, toeCtl[1], t=False, r=True)

		toePos = cmds.xform(grpList[5], q=True, ws=True, rp=True)
		cmds.xform(toeCtl[0], ws=True, rp=toePos)
		cmds.xform(toeCtl[1], ws=True, rp=toePos)
		cmds.orientConstraint(toeCtl[0], end, mo=True)

		# Main Control

		if not ctl:
			ctl = network(n='{}_Network_0'.format(n), typ='foot')
			cmds.setAttr('{}.side'.format(ctl), side, type='string', l=True)

			i = 0
			for null in ['inner', 'outter', 'heel', 'toe', 'ball', 'toeRaise']:
				connectToNetwork(grpList[i], ctl, '{}_pivot'.format(null))
				i += 1

		else:
			cmds.parent(masterGrp, ctl)

		addEmptyAttr(ctl, n='footPivot')

		attrDict = {
			'roll': 0,
			'heelAngle': 45,
			'ballAngle': 45,
			'toeAngle': 70,
			'toeRaise': 0,
			'bank': 0,
		}

		for attr in attrDict:
			cmds.addAttr(ctl, ln=attr, at='double', dv=attrDict[attr], k=True)

		# Control Visibility

		cmds.addAttr(ctl, ln='footControls', at='bool', k=True)
		cmds.setAttr('{}.footControls'.format(ctl), e=True, channelBox=True)

		for x in [ballCtl[1], toeCtl[1]]:
			cmds.connectAttr('{}.footControls'.format(ctl), '{}.v'.format(x))

		# Heel

		mul = cmds.createNode('multDoubleLinear')
		cmds.setAttr('{}.input2'.format(mul), -1)

		cmds.connectAttr('{}.heelAngle'.format(ctl), '{}.input1'.format(mul))

		range = cmds.createNode('setRange')
		cmds.setAttr('{}.oldMinX'.format(range), -10)

		cmds.connectAttr('{}.output'.format(mul), '{}.minX'.format(range))
		cmds.connectAttr('{}.roll'.format(ctl), '{}.valueX'.format(range))

		cmds.connectAttr('{}.outValueX'.format(range), '{}.rx'.format(grpList[2]))

		# Toe Pivot Connections

		range = cmds.createNode('setRange')
		cmds.setAttr('{}.oldMinX'.format(range), 10)
		cmds.setAttr('{}.oldMaxX'.format(range), 20)

		cmds.connectAttr('{}.toeAngle'.format(ctl), '{}.maxX'.format(range))
		cmds.connectAttr('{}.roll'.format(ctl), '{}.valueX'.format(range))

		cmds.connectAttr('{}.outValueX'.format(range), '{}.rx'.format(grpList[3]))
		cmds.connectAttr('{}.toeRaise'.format(ctl), '{}.rx'.format(toeRaise))

		# Ball Pivot Connections

		range = cmds.createNode('setRange')
		cmds.setAttr('{}.oldMaxX'.format(range), 10)
		cmds.setAttr('{}.oldMinY'.format(range), 10)
		cmds.setAttr('{}.oldMaxY'.format(range), 20)

		cmds.connectAttr('{}.ballAngle'.format(ctl), '{}.maxX'.format(range))
		cmds.connectAttr('{}.ballAngle'.format(ctl), '{}.minY'.format(range))
		cmds.connectAttr('{}.roll'.format(ctl), '{}.valueX'.format(range))
		cmds.connectAttr('{}.roll'.format(ctl), '{}.valueY'.format(range))

		con = cmds.createNode('condition')
		cmds.setAttr('{}.secondTerm'.format(con), 10)
		cmds.setAttr('{}.operation'.format(con), 2)

		cmds.connectAttr('{}.roll'.format(ctl), '{}.firstTerm'.format(con))
		cmds.connectAttr('{}.outValueX'.format(range), '{}.colorIfFalseR'.format(con))
		cmds.connectAttr('{}.outValueY'.format(range), '{}.colorIfTrueR'.format(con))
		cmds.connectAttr('{}.outColorR'.format(con), '{}.rx'.format(grpList[4]))

		# Inner / Outter

		con = cmds.createNode('condition')
		cmds.setAttr('{}.operation'.format(con), 2)

		cmds.connectAttr('{}.bank'.format(ctl), '{}.firstTerm'.format(con))
		cmds.connectAttr('{}.bank'.format(ctl), '{}.colorIfTrueR'.format(con))
		cmds.connectAttr('{}.bank'.format(ctl), '{}.colorIfFalseG'.format(con))

		cmds.connectAttr('{}.outColorR'.format(con), '{}.rz'.format(grpList[0]))
		cmds.connectAttr('{}.outColorG'.format(con), '{}.rz'.format(grpList[1]))

		# IK

		if ik:
			cmds.parent(ik, ballCtl[0])

		# Return

		# self.network = net
		self.pivot = grpList
		self.group = masterGrp
		self.control = [ballCtl, toeCtl]
		self.attr = attrDict


#########################################################################################################################
#																														#
#																														#
#	Auto Rig    																								        #
#																														#
#																														#
#########################################################################################################################

class autoRig():
	def __init__(self, characterName='character', *args):

		selected = cmds.ls(sl=True)

		if not selected:
			selected = self.queryScene()

		if selected:
			joints = cmds.listRelatives(selected[0], ad=True, type='joint')
			joints.append(selected[0])

			jointQuery = jointLabel(joints, isDebug=False)

			# BiPed
			root = jointQuery.get(componentType.root)
			cog = jointQuery.get(componentType.cog)
			hip = jointQuery.get(componentType.hip)
			spine = jointQuery.get(componentType.spine)
			head = jointQuery.get(componentType.head)
			armLeft = jointQuery.get(componentType.arm, componentType.left)
			armRight = jointQuery.get(componentType.arm, componentType.right)
			legLeft = jointQuery.get(componentType.leg, componentType.left)
			legRight = jointQuery.get(componentType.leg, componentType.right)

			pUI = progressWindow(st='Creating Control Modules...', max=9)

			ROOT(root)
			pUI.update()

			COG(cog)
			pUI.update()

			HIP(hip)
			pUI.update()

			SPINE(spine)
			pUI.update()

			HEAD(head)
			pUI.update()

			ARM(armLeft)
			pUI.update()

			ARM(armRight)
			pUI.update()

			LEG(legLeft)
			pUI.update()

			LEG(legRight)
			pUI.update()

	def queryScene(self):
		joints = cmds.ls(type='joint')
		return jointLabel(joints).get(componentType.root)


#########################################################################################################################
#																														#
#																														#
#	User Interface																								        #
#																														#
#																														#
#########################################################################################################################


DIRPATH = os.path.dirname(os.path.abspath(__file__))
UIPATH = os.path.join(DIRPATH, 'images')

colorUI = [[.5, 1, .5], [.25, 1, .75], [0, 1, 1], [.25, .75, 1], [.5, .5, 1], [.75, .25, 1], [1, 0, 1],
           [1, .25, .75], [1, .25, .5], [1, .5, .25], [1, 1, .25], [.75, 1, .25]]


def UIImage(n='icon_01.png', *args):
	var = os.path.join(UIPATH, n)
	return var


def button(l='Button', i='circle.png', c=None, bgc=[], *args):
	b = cmds.nodeIconButton(label=l, style='iconAndTextHorizontal', h=40, image1=i, nbg=False)
	if bgc:
		cmds.nodeIconButton(b, e=True, bgc=bgc)
	if c:
		cmds.nodeIconButton(b, e=True, c=c)
	return b


def autoRow(items, label='', *args):
	if label:
		rowUI = cmds.rowLayout(nc=2, ad2=2)
		cmds.text(l=label, al='right', w=10)

	form = cmds.formLayout(nd=100)
	cmds.setParent('..')

	length = float(len(items))
	step = 100 / length

	i = 0
	for x in items:

		if cmds.control(x, q=True, exists=True):

			x = cmds.control(x, e=True, p=form)

		elif cmds.layout(x, q=True, exists=True):
			x = cmds.layout(x, e=True, p=form)

		if i == 0:
			cmds.formLayout(form, edit=True, attachForm=[(x, 'left', 0), (x, 'top', 0), (x, 'bottom', 0), ],
			                attachPosition=[(x, 'right', 1, step), ], )

		else:
			cmds.formLayout(form, edit=True,
			                attachForm=[(x, 'top', 0), (x, 'bottom', 0), ],
			                attachControl=[(x, 'left', 2, items[i - 1]), ],
			                attachPosition=[(x, 'right', 1, step), ]
			                )

		step += 100 / length
		i += 1

	if label:
		cmds.setParent('..')
		return rowUI

	else:
		return form


def divider(label='', mar=10, *args):
	if label:
		ui = cmds.rowLayout(nc=2, ad2=2, )
		cmds.text(l=label + '  ', al='left')
		cmds.columnLayout(bgc=[.5, .5, .5], h=1)
		cmds.setParent('..')
		cmds.setParent('..')
	else:
		ui = cmds.columnLayout(h=mar, adj=True)
		cmds.columnLayout(bgc=[.5, .5, .5], h=1)
		cmds.setParent('..')
		cmds.setParent('..')
	return ui


def colorIndexSlider(l='', c='', index=False, *args):
	indexColor = colorIndexList()
	ui = cmds.colorIndexSliderGrp(l=l, min=1, max=32, value=1, cw=[[1, col], [2, col]], rat=(2, 'both', 0))

	if index:
		cmds.colorIndexSliderGrp(ui, e=True, cc=lambda *x: overrideColor(
			color=cmds.colorIndexSliderGrp(ui, q=True, v=True) - 1, index=True))

	else:
		if c:
			cmds.colorIndexSliderGrp(ui, e=True,
			                         cc=lambda *x: c(indexColor[cmds.colorIndexSliderGrp(ui, q=True, v=True) - 1]))

	return ui


def colorSlider(l='', c='', *args):
	ui = cmds.colorSliderGrp(l=l, cw=[[1, col], [2, col]], rat=(2, 'both', 0))

	if c:
		cmds.colorSliderGrp(ui, e=True, cc=lambda *_: c(cmds.colorSliderGrp(ui, q=True, rgb=True)))

	return ui


def colorPalette(l='', color=[], h=100, d=(), r=4, c='', *args):
	global col

	indexColor = colorIndexList()

	if l:
		cmds.rowLayout(nc=2, ad2=2, cw=(1, col), rat=(1, 'both', 0), cat=(1, 'both', 0))
		cmds.text(l=l, align='right')

	cmds.frameLayout(lv=False)

	if not color:
		color = indexColor

	if not d:
		varW = r
		varH = len(color) / r
		d = (varH, varW)

	port = cmds.palettePort(dim=d, h=h, td=True, ced=False)

	for col in range(len(color)):
		cmds.palettePort(port, e=True, rgb=(col, color[col][0], color[col][1], color[col][2]))

	cmds.setParent('..')

	if c:
		cmds.palettePort(port, e=True, cc=lambda *_: c(color=cmds.palettePort(port, q=True, rgb=True)))

	if l:
		cmds.setParent('..')

	return port


class progressWindow():
	def __init__(self, l='Loading', st='Calculating...', max=100):
		self.value = 0
		self.max = max
		self.ui = cmds.progressWindow(t=l, progress=self.value, st=st, max=max, ii=True)
		self.reachedMax = False

	def update(self, step=1):
		self.value += step
		cmds.progressWindow(self.ui, e=True, progress=self.value)

		if self.value >= self.max:
			self.reachedMax = True
			self.kill()

	def cancel(self):
		if cmds.progressWindow(self.ui, q=True, ic=True):
			self.kill()
			return True
		else:
			return False

	def kill(self):
		cmds.progressWindow(self.ui, endProgress=1)


def selectedDisplayUI(*args):
	ui = cmds.columnLayout(adj=True)
	row = cmds.rowLayout(nc=2)
	cmds.text(l='Selected: ')
	updateSelectedTextUI = cmds.text(l=len(cmds.ls(sl=True)))
	cmds.setParent('..')
	cmds.setParent('..')

	cmds.scriptJob(p=row, protected=True, e=['SelectionChanged', lambda *_: cmds.text(updateSelectedTextUI, e=True,
	                                                                                  l=len(cmds.ls(sl=True)))])
	return ui


def skeletonUI():
	# Header
	ui = cmds.columnLayout(adj=True)

	# Body UI
	cmds.frameLayout(l='Display', mh=mar, mw=mar, bgs=True, cl=True)
	j1 = cmds.button(l='Toggle LRA', enable=False)
	j2 = cmds.button(l='Show', enable=False)
	j3 = cmds.button(l='Hide', enable=False)
	autoRow([j1, j2, j3])
	divider('Joint Scale')
	jdUI = cmds.floatSliderGrp(field=True, pre=2, min=0.01, max=10.00, v=cmds.jointDisplayScale(q=True),
	                           cc=lambda *x: cmds.jointDisplayScale(cmds.floatSliderGrp(jdUI, q=True, v=True)))
	cmds.setParent('..')

	cmds.frameLayout(l='Create', mh=mar, mw=mar, bgs=True, cl=True)
	b1 = cmds.button(l='Create Joint', c=createJoint)
	b2 = cmds.button(l='Orient Chain', c=orientJointChain)
	b3 = cmds.button(l='Select Hierarchy', c=getJointHierarchy)
	autoRow([b1, b2, b3])
	cmds.setParent('..')

	cmds.frameLayout(l='Joint Labels', mh=mar, mw=mar, bgs=True, cl=True)
	a1 = cmds.button(l='Toggle Visibility', c=toggleJointLabel)
	a2 = cmds.button(l='Show', c=lambda *x: mel.eval('displayJointLabels 4;'))
	a3 = cmds.button(l='Hide', c=lambda *x: mel.eval('displayJointLabels 3;'))
	autoRow([a1, a2, a3])

	# Add Label UI
	divider('Add Label')
	cmds.rowLayout(nc=2, adj=1, cat=[1, 'right', -4], rat=[1, 'both', 0])
	om1 = cmds.optionMenuGrp(adj=1, rat=[1, 'both', -2], cat=[1, 'right', 0],
	                         cc=lambda *x: jointLabel().addTypeFromUI(cmds.optionMenuGrp(om1, q=True, sl=True)))
	for l in jointLabel().masterList:
		cmds.menuItem(l=l, dtg=l)
	cmds.button(l='+', w=20, c=lambda *x: jointLabel().addTypeFromUI(cmds.optionMenuGrp(om1, q=True, sl=True)))
	cmds.setParent('..')

	cmds.setParent('..')

	cmds.frameLayout(l='Skinning', mh=mar, mw=mar, bgs=True, cl=True)
	cmds.button(l='Paint Skin Weights Tool', c=lambda *x: mel.eval('ArtPaintSkinWeightsToolOptions;'))
	cmds.button(l='Smooth Skin Weight Tool', c=tf_smoothSkinWeight.paint)
	cmds.button(l='Mirror Skin Weights', c=lambda *x: [skin.mirrorSkinWeights(mesh=x) for x in cmds.ls(sl=True)])
	cmds.setParent('..')

	# End UI
	cmds.setParent('..')

	return ui


def rigUI():
	ui = cmds.columnLayout(adj=True)

	# Root

	cmds.frameLayout(mh=10, mw=10, bgs=True, cll=False, cl=True, lv=False)
	nameField = cmds.textFieldGrp(l='Rig Name: ', tx='character', adj=2, cw2=[60, 60], nbg=False)
	button(l='1. Root', i=UIImage('icon_01_100.png'), c=lambda *x: ROOT(
		name=cmds.textFieldGrp(nameField, q=True, tx=True) if cmds.textFieldGrp(nameField, q=True,
		                                                                        tx=True) else 'character'))
	cmds.setParent('..')

	# Cog

	cmds.frameLayout(l='2. COG Setup', bgs=True, mh=10, mw=10, cll=False, cl=True, lv=False)
	button(l='2. Center of Gravity', i=UIImage('icon_02_100.png'), c=COG)
	cmds.setParent('..')

	# Spine

	cmds.frameLayout(l='3. Spine Setup', bgs=True, mh=10, mw=10, cll=False, cl=True, lv=False)
	button(l='3. Spine', i=UIImage('icon_06_100.png'), c=SPINE)
	cmds.setParent('..')

	# Neck / Head

	cmds.frameLayout(l='4. Neck / Head Setup', bgs=True, mh=10, mw=10, cll=False, cl=True, lv=False)
	button(l='4. Neck / Head', i=UIImage('icon_03_100.png'), c=HEAD)
	cmds.setParent('..')

	# Arms

	cmds.frameLayout(l='5. Arms / Hands', bgs=True, mh=10, mw=10, cll=False, cl=True, lv=False)
	button(l='5. Arm', i=UIImage('icon_05_100.png'), c=ARM)
	cmds.setParent('..')

	# Legs

	cmds.frameLayout(l='6. Legs / Feet', bgs=True, mh=10, mw=10, cll=False, cl=True, lv=False)
	button(l='6. Hip', i=UIImage('icon_04_100.png'), c=HIP)
	button(l='7. Leg', i=UIImage('icon_04_100.png'), c=LEG)
	cmds.setParent('..')

	cmds.setParent('..')

	return ui


def autoUI(*args):
	global procressControl

	# Head UI
	ui = cmds.columnLayout(adj=True)

	# Body UI
	cmds.frameLayout(l='Joint Labels', mh=mar, mw=mar, bgs=True, cl=True)
	a1 = cmds.button(l='Toggle Visibility', c=toggleJointLabel)
	a2 = cmds.button(l='Show', c=lambda *x: mel.eval('displayJointLabels 4;'))
	a3 = cmds.button(l='Hide', c=lambda *x: mel.eval('displayJointLabels 3;'))
	autoRow([a1, a2, a3])

	# Add Label UI
	divider('Add Label')
	cmds.rowLayout(nc=2, adj=1, cat=[1, 'right', -4], rat=[1, 'both', 0])
	om1 = cmds.optionMenuGrp(adj=1, rat=[1, 'both', -2], cat=[1, 'right', 0],
	                         cc=lambda *x: jointLabel().addTypeFromUI(cmds.optionMenuGrp(om1, q=True, sl=True)))
	for l in jointLabel().masterList:
		cmds.menuItem(l=l, dtg=l)
	cmds.button(l='+', w=20, c=lambda *x: jointLabel().addTypeFromUI(cmds.optionMenuGrp(om1, q=True, sl=True)))
	cmds.setParent('..')

	cmds.button(l='Create Rig', c=autoRig)

	cmds.setParent('..')

	# End UI
	cmds.setParent('..')

	return ui


def colorUI(cl=True, cll=True, *args):
	ui = cmds.columnLayout(adj=True)

	cmds.frameLayout(l='Color', mh=mar, mw=mar, bgs=True, cl=cl, cll=cll)
	cmds.button(l='Disable Color', c=lambda *x: overrideColor(reset=True))
	divider('Index')
	colorPalette(c=overrideColor)
	cmds.setParent('..')
	cmds.setParent('..')

	return ui


class getAllInScene():

	def __init__(self):
		self.ui()

	def get(self, dupe=False, *args):
		uiquery = cmds.optionMenu(self.getAllInSceneOptionUI, q=True, v=True)

		objectList = []

		if dupe == True:

			objects = [f for f in cmds.ls() if '|' in f]
			objects.sort(key=lambda obj: obj.count('|'), reverse=True)

			for obj in objects:
				objectList.append(obj)


		else:

			objects = cmds.ls(type=uiquery)

			for obj in objects:
				if cmds.objectType(obj) == uiquery:
					objectList.append(obj)

		cmds.textScrollList(self.getAllInSceneListUI, e=True, ra=True)
		cmds.textScrollList(self.getAllInSceneListUI, e=True, append=objectList)

	def selectTextScrollObject(self, control, *args):
		uiquery = cmds.textScrollList(control, q=True, si=True)

		try:
			cmds.select(uiquery)
		except:
			pass

	def ui(self, cl=True, h=100, *args):
		cmds.columnLayout(adj=True)
		cmds.frameLayout(l='List Objects in Scene', cl=cl, mh=mar, mw=mar, bgs=True, cll=True,
		                 ann='Find all nodes in the scene by type.')

		cmds.rowLayout(nc=2, ad2=1, rat=[1, 'both', -2], cat=[1, 'left', -2])
		self.getAllInSceneOptionUI = cmds.optionMenu(cc=self.get)
		nodeList = ['transform', 'locator', 'mesh', 'joint', 'network', 'nurbsSurface', 'nurbsCurve']
		for opt in sorted(nodeList):
			cmds.menuItem(l=opt, p=self.getAllInSceneOptionUI)
		b1 = cmds.button(l='Find Duplicates', c=lambda *x: self.get(dupe=True))
		cmds.setParent('..')

		self.getAllInSceneListUI = cmds.textScrollList(h=h,
		                                               sc=lambda *x: self.selectTextScrollObject(
			                                               self.getAllInSceneListUI))
		cmds.setParent('..')
		cmds.setParent('..')

		self.get()


def miscUI(cl=True, cll=True, *args):
	ui = cmds.columnLayout(adj=True)
	cmds.frameLayout(l='Misc.', mh=mar, mw=mar, bgs=True, cl=cl, cll=cll)
	cmds.button(l='Create Locator')
	cmds.button(l='Snap')
	cmds.setParent('..')
	cmds.setParent('..')
	return ui


def toolUI(*args):
	ui = cmds.columnLayout(adj=True)
	getAllInScene()
	colorUI()
	miscUI()
	cmds.setParent('..')
	return ui


# Main Window UI


def UI():
	uiName = 'JTRIGTOOLS'
	if cmds.window(uiName, exists=True):
		cmds.deleteUI(uiName, window=True)

	win = cmds.window(uiName, title=uiName)

	# Start Header

	form = cmds.formLayout()
	sUI = selectedDisplayUI()

	# Start Body

	tab = cmds.tabLayout()
	tab0 = toolUI()
	tab1 = skeletonUI()
	tab2 = rigUI()
	tab3 = autoUI()

	# End Body

	cmds.formLayout(form, e=True,
	                attachForm=((sUI, 'top', 0), (sUI, 'left', 0), (sUI, 'right', 0),))

	cmds.formLayout(form, e=True,
	                attachForm=((tab, 'bottom', 0), (tab, 'left', 0), (tab, 'right', 0),),
	                attachControl=(tab, 'top', 0, sUI), )

	cmds.tabLayout(tab, e=True, tabLabel=((tab0, 'Tools'), (tab1, 'Skeleton'), (tab2, 'Modules'), (tab3, 'Auto Rig')))

	cmds.setParent('..')

	cmds.setParent('..')
	cmds.setParent('..')  # end form
	cmds.showWindow(uiName)
